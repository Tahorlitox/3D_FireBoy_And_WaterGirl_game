<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FireBoy & WaterGirl</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a202c; }
        canvas { display: block; }
        .hidden { display: none !important; }
        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: white; font-family: 'Press Start 2P', monospace;
            text-align: center;
        }
        .menu-screen h1 { font-size: 5rem; color: #4299e1; text-shadow: 4px 4px 0px #2b6cb0; margin-bottom: 3rem; }
        #mode-select { display: flex; gap: 2rem; }
        .mode-button {
            font-family: 'Press Start 2P', monospace; font-size: 1.5rem;
            padding: 1rem 2rem; border: 4px solid; cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .mode-button:hover { transform: scale(1.1); }
        #teamwork-button { border-color: #f6e05e; background-color: #ecc94b; color: #975a16; }
        #teamwork-button:hover { box-shadow: 0 0 20px #f6e05e; }
        #competition-button { border-color: #f56565; background-color: #e53e3e; color: #742a2a; }
        #competition-button:hover { box-shadow: 0 0 20px #f56565; }
        #game-container { position: relative; }
        #split-border {
            position: absolute; left: 50%; top: 0; bottom: 0;
            width: 4px; background-color: #ecf0f1;
            transform: translateX(-50%); pointer-events: none;
        }
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            justify-content: center; align-items: center; font-family: 'Press Start 2P', monospace;
        }
        .menu-box {
            background-color: #2d3748; padding: 2rem 3rem; border-radius: 10px;
            border: 4px solid #4a5568; text-align: center; color: white;
        }
        .menu-box h1 { font-size: 2.5rem; margin-bottom: 2rem; }
        .menu-box button {
            font-family: 'Press Start 2P', monospace; font-size: 1rem;
            padding: 0.8rem 1.5rem; border: 3px solid; cursor: pointer;
            transition: all 0.2s ease-in-out; display: block;
            width: 100%; margin-bottom: 1rem;
        }
        .menu-box button:last-child { margin-bottom: 0; }
        .menu-box p { margin-bottom: 1.5rem; }
        .menu-box button:disabled { background-color: #4a5568; border-color: #2d3748; color: #718096; cursor: not-allowed; }
        .menu-box button:disabled:hover { transform: none; }
        #winner-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; font-family: 'Press Start 2P', monospace;
            text-align: center; color: white;
        }
        #winner-screen h1 { font-size: 4rem; margin-bottom: 2rem; text-shadow: 4px 4px 0px rgba(0,0,0,0.5); animation: pulse 2s infinite; }
        #winner-screen p { font-size: 1.5rem; margin-bottom: 3rem; opacity: 0.8; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', monospace; font-size: 8rem; color: #f56565;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); z-index: 1000; pointer-events: none;
        }
        .gem-ui {
            position: absolute;
            top: 20px;
            font-family: 'Press Start 2P', monospace;
            color: white;
            font-size: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }
        #player1-gem-ui { left: 20px; }
        #player2-gem-ui { left: calc(50% + 20px); }
    </style>
</head>
<body>
    <div id="main-menu" class="menu-screen">
        <h1>3D FireBoy & WaterGirl</h1>
        <div id="mode-select">
            <button id="teamwork-button" class="mode-button">Survival Mode</button>
            <button id="competition-button" class="mode-button">1 vs 1</button>
        </div>
    </div>
    <div id="submenu" class="menu-screen hidden">
        <div class="menu-box">
            <h1>Survival Mode</h1>
            <button id="resume-game-button">Resume Game</button>
            <button id="new-game-button">New Game</button>
            <button id="start-game-button" class="hidden">Start Game</button>
            <button id="back-to-main-button">Back</button>
        </div>
    </div>
    <div id="confirmation-dialog" class="menu-screen hidden">
        <div class="menu-box">
            <p>Start a new game?<br>All progress will be lost!</p>
            <button id="confirm-yes-button">Yes</button>
            <button id="confirm-no-button">No</button>
        </div>
    </div>
    <div id="winner-screen" class="hidden">
        <h1 id="winner-text">Player 1 Wins!</h1>
        <p id="winner-subtext">First to reach the finish line!</p>
        <div class="menu-box">
            <button id="race-again-button">Play Again</button>
            <button id="back-to-menu-button">Back to Menu</button>
        </div>
    </div>
    <div id="game-container" class="hidden">
        <div id="split-border"></div>
        <div id="countdown" class="hidden"></div>
        <div id="player1-gem-ui" class="gem-ui"></div>
        <div id="player2-gem-ui" class="gem-ui"></div>
        <div id="pause-menu" class="menu-overlay hidden">
            <div class="menu-box">
                <h1>Paused</h1>
                <button id="resume-button">Resume</button>
                <button id="restart-checkpoint-button">Restart from Checkpoint</button>
                <button id="return-to-menu-button">Return to Menu</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
    
        // --- UI ELEMENTS ---
        const mainMenu = document.getElementById('main-menu');
        const submenu = document.getElementById('submenu');
        const teamworkButton = document.getElementById('teamwork-button');
        const competitionButton = document.getElementById('competition-button');
        const resumeGameButton = document.getElementById('resume-game-button');
        const newGameButton = document.getElementById('new-game-button');
        const startGameButton = document.getElementById('start-game-button');
        const backToMainButton = document.getElementById('back-to-main-button');
        const gameContainer = document.getElementById('game-container');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const restartCheckpointButton = document.getElementById('restart-checkpoint-button');
        const returnToMenuButton = document.getElementById('return-to-menu-button');
        const confirmationDialog = document.getElementById('confirmation-dialog');
        const confirmYesButton = document.getElementById('confirm-yes-button');
        const confirmNoButton = document.getElementById('confirm-no-button');
        const winnerScreen = document.getElementById('winner-screen');
        const winnerText = document.getElementById('winner-text');
        const winnerSubtext = document.getElementById('winner-subtext'); 
        const raceAgainButton = document.getElementById('race-again-button');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const countdown = document.getElementById('countdown');
        const player1GemUI = document.getElementById('player1-gem-ui');
        const player2GemUI = document.getElementById('player2-gem-ui');
    
        // --- GAME STATE ---
        let gameState = 'menu';
        let gameMode = 'none';
        let animationFrameId;
        let highestLevelUnlocked = 0;
        let hasSavedProgress = false;
        let savedSpawnPoint = null;
        let raceFinished = false;
        let totalRedCollectibles = 0;
        let totalBlueCollectibles = 0;
        let totalNeutralCollectibles = 0;
        let redCollectedCount = 0;
        let blueCollectedCount = 0;
        let neutralCollectedCount = 0;

    
        // --- SAVE/LOAD ---
        function loadProgress() {
            const savedLevel = localStorage.getItem('3dup-up_progress');
            const savedSpawn = localStorage.getItem('3dup-up_spawnPoint');
            if (savedLevel !== null) {
                highestLevelUnlocked = parseInt(savedLevel);
                hasSavedProgress = true;
            } else {
                highestLevelUnlocked = 0;
                hasSavedProgress = false;
            }
            if (savedSpawn) {
                savedSpawnPoint = JSON.parse(savedSpawn);
            } else {
                savedSpawnPoint = null;
            }
        }
    
        function saveProgress() {
            localStorage.setItem('3dup-up_progress', highestLevelUnlocked.toString());
            localStorage.setItem('3dup-up_spawnPoint', JSON.stringify(players[0].spawnPoint));
            hasSavedProgress = true;
        }
    
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        gameContainer.appendChild(renderer.domElement);
        const camera1 = new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);
        const camera2 = new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);

        // --- GAME OBJECTS ---
        const platforms = [];
        const checkpoints = [];
        const hazards = [];
        const pressurePlates = [];
        const goals = [];
        const collectibles = [];
        const levers = [];
        const movingPlatforms = [];
        const doors = [];
        const pushers = [];
        const pushableObjects = [];
        const dualPressurePlates = [];
        // NEW: Player 1 (WASD) is now Fireboy (Red), Player 2 (Arrows) is Watergirl (Blue)
        const player1 = createPlayer(0xff3300, 'fire'); // Red
        scene.add(player1);
        const player2 = createPlayer(0x3366ff, 'water'); // Blue
        scene.add(player2);

        const players = [
            { object: player1, velocityY: 0, isGrounded: true, groundedOn: null, spawnPoint: new THREE.Vector3(-2, 0.5, 0), controls: { forward: 'w', back: 's', left: 'a', right: 'd', jump: ' ', interact: 'e' }, type: 'fire', name: 'Fireboy', walkPhase: 0 },
            { object: player2, velocityY: 0, isGrounded: true, groundedOn: null, spawnPoint: new THREE.Vector3(2, 0.5, 0), controls: { forward: 'arrowup', back: 'arrowdown', left: 'arrowleft', right: 'arrowright', jump: 'shift', interact: 'enter' }, type: 'water', name: 'Watergirl', walkPhase: 0 }
        ];
        const floorGeometry = new THREE.PlaneGeometry(120, 120);
        // NEW: Floor material and mesh with color of real earth
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        floorMaterial.map = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        floorMaterial.map.wrapS = THREE.RepeatWrapping;
        floorMaterial.map.wrapT = THREE.RepeatWrapping;
        floorMaterial.map.repeat.set(15, 15);
        floorMaterial.needsUpdate = true;
        floorMaterial.side = THREE.DoubleSide; // Ensure both sides are rendered
        floorMaterial.transparent = true; // Allow transparency for better visuals
        floorMaterial.opacity = 0.9; // Slightly transparent for a better look
        floorGeometry.computeVertexNormals(); // Ensure normals are correct for lighting
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        platforms.push(floor);
        // very bright ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- AUDIO SETUP ---
        const listener1 = new THREE.AudioListener();
        camera1.add(listener1);
        const listener2 = new THREE.AudioListener();
        camera2.add(listener2);

        const audioLoader = new THREE.AudioLoader();
        const jumpFbSound = new THREE.Audio(listener1);
        const jumpWgSound = new THREE.Audio(listener2);
        const SurvivalMusic = new THREE.Audio(listener1);
        const CompetitionMusic = new THREE.Audio(listener1);
        const collectSound = new THREE.Audio(listener1);

        audioLoader.load('JumpFb.mp3', (buffer) => {
            jumpFbSound.setBuffer(buffer);
            jumpFbSound.setVolume(0.5);
        });
        audioLoader.load('JumpWg.mp3', (buffer) => {
            jumpWgSound.setBuffer(buffer);
            jumpWgSound.setVolume(0.5);
        });
        audioLoader.load('SurvivalMusic1.mp3', (buffer) => {
            SurvivalMusic.setBuffer(buffer);
            SurvivalMusic.setVolume(0.5);
        });
        audioLoader.load('CompetitionMusic.mp3', (buffer) => {
            CompetitionMusic.setBuffer(buffer);
            CompetitionMusic.setVolume(0.5);
        });
        audioLoader.load('collect.mp3', (buffer) => {
            collectSound.setBuffer(buffer);
            collectSound.setVolume(0.7);
        });

        // --- INPUT HANDLING ---
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
        document.addEventListener('wheel', (e) => {
            if (gameState !== 'playing' && gameState !== 'paused') return;

            const zoomSpeed = 0.01;
            let currentLength = cameraOffset.length();
            // e.deltaY is positive for scrolling down (zoom out) and negative for up (zoom in)
            let newLength = currentLength + e.deltaY * zoomSpeed;

            // Clamp the zoom distance to prevent going too close or too far
            const minZoom = 5;
            const maxZoom = 20;
            cameraOffset.setLength(Math.max(minZoom, Math.min(maxZoom, newLength)));
        });

        // --- CORE GAME LOGIC ---
        const playerSpeed = 0.1;
        const playerRotationSpeed = 0.05;
        const gravity = -0.015;
        const jumpHeight = 0.3;

        function createPlayer(color, type) {
    const playerGroup = new THREE.Group();

    // Materials
    const bodyMaterial = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.5 });
    const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc });
    const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

    // Head (Voxel structure)
    const headGroup = new THREE.Group();
    const headColor = (type === 'fire') ? 0xff3333 : 0x3399ff;

    const voxelMaterial = new THREE.MeshStandardMaterial({ color: headColor, emissive: headColor, emissiveIntensity: 0.4 });
    
    // Create voxel head as a grid of blocks
    for (let x = -1; x <= 1; x++) {
        for (let y = 0; y <= 2; y++) {
            for (let z = -1; z <= 1; z++) {
                if (Math.random() > 0.3 || y > 0) { // random blocky shape
                    const block = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), voxelMaterial);
                    block.position.set(x * 0.2, y * 0.2, z * 0.2);
                    headGroup.add(block);
                }
            }
        }
    }

    // Top flame or water bun
    if (type === 'fire') {
        for (let i = 0; i < 3; i++) {
            const flame = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), voxelMaterial);
            flame.position.set((i - 1) * 0.2, 0.7, 0);
            headGroup.add(flame);
        }
    } else {
        const bun = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), voxelMaterial);
        bun.position.set(0, 0.7, 0);
        headGroup.add(bun);
    }

    // Eyes
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.05), eyeWhiteMaterial);
    eyeL.position.set(-0.2, 0.4, 0.35);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.2;

    const pupilL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), pupilMaterial);
    pupilL.position.set(-0.2, 0.4, 0.38);
    const pupilR = pupilL.clone();
    pupilR.position.x = 0.2;

    headGroup.add(eyeL, eyeR, pupilL, pupilR);
    headGroup.position.y = 1.5;
    // rotate head 180 degrees to face forward
    headGroup.rotation.y = Math.PI;

    // Body (simple block)
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.4), voxelMaterial);
    body.position.y = 0.8;

    // Arms
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), voxelMaterial);
    armL.position.set(-0.35, 1, 0);
    const armR = armL.clone();
    armR.position.x = 0.35;

    // Legs
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.5, 0.2), voxelMaterial);
    legL.position.set(-0.15, 0.25, 0);
    const legR = legL.clone();
    legR.position.x = 0.15;

    // Light emission (optional glow)
    const glow = new THREE.PointLight(color, 1, 5);
    glow.position.y = 1.5;

    playerGroup.add(body, headGroup, armL, armR, legL, legR, glow);
    playerGroup.userData.anim = { headGroup, body, armL, armR, legL, legR };
    return playerGroup;
}

    
        function clearLevel() {
            for (let i = platforms.length - 1; i > 0; i--) scene.remove(platforms.pop());
            checkpoints.forEach(c => c.pair.forEach(door => scene.remove(door)));
            checkpoints.length = 0;
            hazards.forEach(h => scene.remove(h.object));
            hazards.length = 0;
            goals.forEach(g => scene.remove(g.object));
            goals.length = 0;
            levers.forEach(l => {
                scene.remove(l.mesh);
                scene.remove(l.handleMesh);
            });
            levers.length = 0;
            movingPlatforms.forEach(p => scene.remove(p.mesh));
            movingPlatforms.length = 0;
            collectibles.forEach(c => scene.remove(c.mesh));
            collectibles.length = 0;

            // NEW: Clear new interactive elements
            pressurePlates.forEach(p => scene.remove(p.mesh));
            pressurePlates.length = 0;
            dualPressurePlates.forEach(p => scene.remove(p.mesh));
            dualPressurePlates.length = 0;
            doors.forEach(d => scene.remove(d.mesh));
            doors.length = 0;
            pushers.forEach(p => scene.remove(p.mesh));
            pushers.length = 0;
            pushableObjects.forEach(p => scene.remove(p.mesh));
            pushableObjects.length = 0;

            totalRedCollectibles = 0;
            totalBlueCollectibles = 0;
            totalNeutralCollectibles = 0;
            redCollectedCount = 0;
            blueCollectedCount = 0;
            neutralCollectedCount = 0;
        }
    
        /*
        function buildTeamworkLevel_original() {
            clearLevel();
            const platMat = new THREE.MeshStandardMaterial({ color: 0x68d391 });
            const plat1 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 4), platMat);
            plat1.position.set(-5, 2, 0);
            scene.add(plat1);
            platforms.push(plat1);
            const plat2 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), platMat);
            plat2.position.set(0, 4, -5);
            scene.add(plat2);
            platforms.push(plat2);
            const plat3 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 8), platMat);
            plat3.position.set(5, 6, 0);
            scene.add(plat3);
            platforms.push(plat3);
            const plat4 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), platMat);
            plat4.position.set(5, 5, -10);
            scene.add(plat4);
            platforms.push(plat4);
            const cpMatB = new THREE.MeshStandardMaterial({ color: 0x00c6ff, transparent: true, opacity: 0.5 });
            const cpMatR = new THREE.MeshStandardMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.5 });
            const cpDoor1 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.2), cpMatR);
            cpDoor1.position.set(-6, 3.5, 0);
            scene.add(cpDoor1);
            const cpDoor2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.2), cpMatB);
            cpDoor2.position.set(-4, 3.5, 0);
            scene.add(cpDoor2);
            checkpoints.push({ pair: [cpDoor1, cpDoor2], spawnPoint: new THREE.Vector3(-5, 3, 0), activated: false });

            // NEW: Thematic hazards
            const hazardRedMat = new THREE.MeshStandardMaterial({ color: 0xe53e3e });
            const hazardBlueMat = new THREE.MeshStandardMaterial({ color: 0x3182ce });
            
            const firePit = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), hazardRedMat);
            firePit.position.set(0, 4.6, -6);
            scene.add(firePit);
            hazards.push({ object: firePit, harmfulTo: 1 }); // Harmful to Watergirl (player 1)

            const waterPuddle = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), hazardBlueMat);
            waterPuddle.position.set(5, 6.6, 1);
            scene.add(waterPuddle);
            hazards.push({ object: waterPuddle, harmfulTo: 0 }); // Harmful to Fireboy (player 0)

            // MODIFIED: The moving platform now follows a path defined by waypoints
            const movingPlatMat = new THREE.MeshStandardMaterial({ color: 0xf6e05e });
            const movingPlat = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 3), movingPlatMat);
            const waypoints = [
                new THREE.Vector3(0, 1, -10),  // Start position (returns here when inactive)
                new THREE.Vector3(0, 5, -10),  // Path point 1: Up
                new THREE.Vector3(5, 5, -10)   // Path point 2: Right
            ];
            movingPlat.position.copy(waypoints[0]);
            scene.add(movingPlat);
            platforms.push(movingPlat); // Add to platforms for collision
            const platformController = {
                mesh: movingPlat,
                waypoints: waypoints,
                currentTargetIndex: 1, // Start by moving towards the second point in the array
                speed: 0.02,
                isActive: false,
                velocity: new THREE.Vector3()
            };
            movingPlatforms.push(platformController);
            const leverBaseMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const leverHandleMat = new THREE.MeshStandardMaterial({ color: 0xa0aec0 });
            const leverBase = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), leverBaseMat);
            leverBase.position.set(2, 4.5, -5); // On the second platform
            scene.add(leverBase);
            const leverHandle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.1), leverHandleMat);
            leverHandle.position.set(2, 5.1, -5);
            leverHandle.geometry.translate(0, -0.5, 0); // Set pivot to bottom
            leverHandle.rotation.z = -Math.PI / 4;
            scene.add(leverHandle);
            levers.push({ mesh: leverBase, handleMesh: leverHandle, activated: false, linkedObject: platformController });

            // NEW: Final platform and player-specific goal doors
            const finalPlatform = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 6), platMat);
            finalPlatform.position.set(0, 8, -15);
            scene.add(finalPlatform);
            platforms.push(finalPlatform);

            const fireDoorMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const waterDoorMat = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });

            const fireDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), fireDoorMat);
            fireDoor.position.set(-1.5, 9.75, -15); // On top of the final platform
            scene.add(fireDoor);
            goals.push({ object: fireDoor, player: 0 }); // Goal for Fireboy

            const waterDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), waterDoorMat);
            waterDoor.position.set(1.5, 9.75, -15); // On top of the final platform
            scene.add(waterDoor);
            goals.push({ object: waterDoor, player: 1 }); // Goal for Watergirl

            // NEW: Add a pusher
            const pusherMat = new THREE.MeshStandardMaterial({ color: 0x9f7aea, emissive: 0x9f7aea, emissiveIntensity: 0.4 });
            const pusherMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 0.5), pusherMat);
            const pusherStart = new THREE.Vector3(2, 1, -8);
            const pusherEnd = new THREE.Vector3(-2, 1, -8);
            pusherMesh.position.copy(pusherStart);
            scene.add(pusherMesh);
            pushers.push({
                mesh: pusherMesh,
                startPos: pusherStart,
                endPos: pusherEnd,
                speed: 0.03,
                direction: 1,
                velocity: new THREE.Vector3()
            });

            // NEW: Add a pressure plate and a gate (door)
            const pressurePlateMat = new THREE.MeshStandardMaterial({ color: 0xf6ad55 });
            const pressurePlateMesh = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), pressurePlateMat);
            pressurePlateMesh.position.set(0, 8.6, -10); // On the final platform
            scene.add(pressurePlateMesh);

            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const doorMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.5), doorMat);
            const doorStart = new THREE.Vector3(0, 10, -12);
            const doorEnd = new THREE.Vector3(0, 7, -12); // Moves down
            doorMesh.position.copy(doorStart);
            scene.add(doorMesh);
            
            const doorObject = {
                mesh: doorMesh,
                startPos: doorStart,
                endPos: doorEnd,
            };
            doors.push(doorObject);
            platforms.push(doorMesh); // Add door to platforms for collision

            pressurePlates.push({
                mesh: pressurePlateMesh,
                linkedDoor: doorObject,
                isPressed: false
            });

            // NEW: Add collectibles
            const redGemMat = new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0xff5555, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const blueGemMat = new THREE.MeshStandardMaterial({ color: 0x5599ff, emissive: 0x5599ff, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const neutralGemMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0xcccccc, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 });
            const gemGeo = new THREE.OctahedronGeometry(0.3, 0);
            const gemData = [
                { pos: new THREE.Vector3(-5, 3.5, 0), type: 'fire' },
                { pos: new THREE.Vector3(0, 5.5, -5), type: 'water' },
                { pos: new THREE.Vector3(5, 7.5, 0), type: 'fire' },
                { pos: new THREE.Vector3(5, 6.5, -10), type: 'water' },
                { pos: new THREE.Vector3(0, 9, -12), type: 'fire' },
                // NEW: Neutral gems
                { pos: new THREE.Vector3(0, 2, -2), type: 'neutral' },
                { pos: new THREE.Vector3(2.5, 6.5, -7.5), type: 'neutral' }
            ];
            gemData.forEach(data => {
                const mat = data.type === 'fire' ? redGemMat : (data.type === 'water' ? blueGemMat : neutralGemMat);
                const gem = new THREE.Mesh(gemGeo, mat);
                gem.position.copy(data.pos);
                scene.add(gem);
                collectibles.push({ mesh: gem, type: data.type });
                if (data.type === 'fire') {
                    totalRedCollectibles++;
                } else if (data.type === 'water') {
                    totalBlueCollectibles++;
                } else {
                    totalNeutralCollectibles++;
                }
            });

            // NEW: Add a dual pressure plate and a gate that requires both players
            const dualPlateMat = new THREE.MeshStandardMaterial({ color: 0x9f7aea, emissive: 0x9f7aea, emissiveIntensity: 0.2 });
            const dualPlateMesh = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), dualPlateMat);
            dualPlateMesh.position.set(-5, 2.6, 2); // On the first big platform
            scene.add(dualPlateMesh);

            const dualDoorMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const dualDoorMesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 4), dualDoorMat);
            const dualDoorStart = new THREE.Vector3(-2, 2, -3); // Blocking the path to the next platform
            const dualDoorEnd = new THREE.Vector3(-2, -2, -3); // Moves down out of the way
            dualDoorMesh.position.copy(dualDoorStart);
            scene.add(dualDoorMesh);

            const dualDoorObject = {
                mesh: dualDoorMesh,
                startPos: dualDoorStart,
                endPos: dualDoorEnd,
            };
            doors.push(dualDoorObject); // Re-use the doors array for the object itself
            platforms.push(dualDoorMesh); // Add door to platforms for collision

            dualPressurePlates.push({
                mesh: dualPlateMesh,
                linkedDoor: dualDoorObject,
                isPressed: false,
                player1On: false, // Track each player
                player2On: false
            });

            // NEW: Add pushable objects
            const pushableMat = new THREE.MeshStandardMaterial({ color: 0x718096, metalness: 0.2, roughness: 0.8 });
            const pushableCube = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), pushableMat);
            const cubeStartPos = new THREE.Vector3(5, 7, 2);
            pushableCube.position.copy(cubeStartPos); // On the third platform
            scene.add(pushableCube);
            platforms.push(pushableCube);
            pushableObjects.push({
                mesh: pushableCube,
                velocity: new THREE.Vector3(),
                isGrounded: false,
                mass: 2.0, // Heavier
                frameVelocity: new THREE.Vector3(),
                startPos: cubeStartPos.clone()
            });

            const pushableSphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 16), pushableMat);
            const sphereStartPos = new THREE.Vector3(5, 7, -2);
            pushableSphere.position.copy(sphereStartPos); // On the third platform
            scene.add(pushableSphere);
            platforms.push(pushableSphere);
            pushableObjects.push({
                mesh: pushableSphere,
                velocity: new THREE.Vector3(),
                isGrounded: false,
                mass: 1.0, // Lighter
                frameVelocity: new THREE.Vector3(),
                startPos: sphereStartPos.clone()
            });
        }
        */
        function buildTeamworkLevel() {
            clearLevel();

            // --- MATERIALS ---
            const platMat = new THREE.MeshStandardMaterial({ color: 0x68d391 });
            const hazardRedMat = new THREE.MeshStandardMaterial({ color: 0xe53e3e });
            const hazardBlueMat = new THREE.MeshStandardMaterial({ color: 0x3182ce });
            const leverBaseMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const leverHandleMat = new THREE.MeshStandardMaterial({ color: 0xa0aec0 });
            const movingPlatMat = new THREE.MeshStandardMaterial({ color: 0xf6e05e });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
            const pressurePlateMat = new THREE.MeshStandardMaterial({ color: 0xf6ad55 });
            const dualPlateMat = new THREE.MeshStandardMaterial({ color: 0x9f7aea, emissive: 0x9f7aea, emissiveIntensity: 0.2 });
            const pushableMat = new THREE.MeshStandardMaterial({ color: 0x718096, metalness: 0.2, roughness: 0.8 });
            const fireDoorMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const waterDoorMat = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const redGemMat = new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0xff5555, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const blueGemMat = new THREE.MeshStandardMaterial({ color: 0x5599ff, emissive: 0x5599ff, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const neutralGemMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0xcccccc, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 });
            const gemGeo = new THREE.OctahedronGeometry(0.3, 0);


            // --- SECTION 1: THE SPLIT PATH ---

            // Start platform
            const startPlat = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 6), platMat);
            startPlat.position.set(0, 0, 0);
            scene.add(startPlat);
            platforms.push(startPlat);

            // Path for Player 1 (Fireboy)
            const p1_plat1 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 12), platMat);
            p1_plat1.position.set(-7, 0, -9);
            scene.add(p1_plat1);
            platforms.push(p1_plat1);

            // Water hazards on Fireboy's path
            const water1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), hazardBlueMat);
            water1.position.set(-7, 1, -6);
            scene.add(water1);
            hazards.push({ object: water1, harmfulTo: 0 });

            const water2 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), hazardBlueMat);
            water2.position.set(-7, 1, -12);
            scene.add(water2);
            hazards.push({ object: water2, harmfulTo: 0 });

            // Path for Player 2 (Watergirl)
            const p2_plat1 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 12), platMat);
            p2_plat1.position.set(7, 0, -9);
            scene.add(p2_plat1);
            platforms.push(p2_plat1);

            // Fire hazards on Watergirl's path
            const fire1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), hazardRedMat);
            fire1.position.set(7, 1, -6);
            scene.add(fire1);
            hazards.push({ object: fire1, harmfulTo: 1 });

            const fire2 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), hazardRedMat);
            fire2.position.set(7, 1, -12);
            scene.add(fire2);
            hazards.push({ object: fire2, harmfulTo: 1 });

            // Lever for Fireboy to open a door for Watergirl
            const lever1Base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1, 0.5), leverBaseMat);
            lever1Base.position.set(-7, 1.5, -15);
            scene.add(lever1Base);
            const lever1Handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.2, 0.1), leverHandleMat);
            lever1Handle.position.set(-7, 2.1, -15);
            lever1Handle.geometry.translate(0, -0.5, 0);
            lever1Handle.rotation.z = -Math.PI / 4;
            scene.add(lever1Handle);

            const door1Mesh = new THREE.Mesh(new THREE.BoxGeometry(4, 3, 0.5), doorMat);
            const door1Start = new THREE.Vector3(7, 1.5, -18);
            const door1End = new THREE.Vector3(7, -1.5, -18);
            door1Mesh.position.copy(door1Start);
            scene.add(door1Mesh);
            const door1Object = { mesh: door1Mesh, startPos: door1Start, endPos: door1End };
            doors.push(door1Object);
            platforms.push(door1Mesh);

            levers.push({ mesh: lever1Base, handleMesh: lever1Handle, activated: false, linkedObject: { isActive: false, door: door1Object } });

            // --- SECTION 2: THE VERTICAL CHALLENGE ---

            // Rejoining platform
            const rejoinPlat = new THREE.Mesh(new THREE.BoxGeometry(14, 1, 6), platMat);
            rejoinPlat.position.set(0, -1, -22);
            scene.add(rejoinPlat);
            platforms.push(rejoinPlat);

            // Vertical moving platform controlled by a dual pressure plate
            const dualPlate1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), dualPlateMat);
            dualPlate1.position.set(0, 0, -20);
            scene.add(dualPlate1);

            const movingPlat1 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 3), movingPlatMat);
            const mp1Waypoints = [new THREE.Vector3(0, 0, -25), new THREE.Vector3(0, 8, -25)];
            movingPlat1.position.copy(mp1Waypoints[0]);
            scene.add(movingPlat1);
            platforms.push(movingPlat1);
            const mp1Controller = { mesh: movingPlat1, waypoints: mp1Waypoints, currentTargetIndex: 1, speed: 0.03, isActive: false, velocity: new THREE.Vector3() };
            movingPlatforms.push(mp1Controller);

            dualPressurePlates.push({ mesh: dualPlate1, linkedDoor: { mesh: movingPlat1, startPos: mp1Waypoints[0], endPos: mp1Waypoints[1] }, isPressed: false, player1On: false, player2On: false });

            // Upper platform
            const upperPlat1 = new THREE.Mesh(new THREE.BoxGeometry(10, 1, 6), platMat);
            upperPlat1.position.set(0, 8, -30);
            scene.add(upperPlat1);
            platforms.push(upperPlat1);

            // Pushable block puzzle
            const pushableCube1 = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), pushableMat);
            const cube1StartPos = new THREE.Vector3(4, 9.5, -30);
            pushableCube1.position.copy(cube1StartPos);
            scene.add(pushableCube1);
            platforms.push(pushableCube1);
            pushableObjects.push({ mesh: pushableCube1, velocity: new THREE.Vector3(), isGrounded: false, mass: 2.0, frameVelocity: new THREE.Vector3(), startPos: cube1StartPos.clone() });

            const pressurePlate1 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), pressurePlateMat);
            pressurePlate1.position.set(-4, 9, -30);
            scene.add(pressurePlate1);

            const door2Mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 4, 4), doorMat);
            const door2Start = new THREE.Vector3(0, 11, -33);
            const door2End = new THREE.Vector3(0, 7, -33);
            door2Mesh.position.copy(door2Start);
            scene.add(door2Mesh);
            const door2Object = { mesh: door2Mesh, startPos: door2Start, endPos: door2End };
            doors.push(door2Object);
            platforms.push(door2Mesh);

            pressurePlates.push({ mesh: pressurePlate1, linkedDoor: door2Object, isPressed: false });


            // --- SECTION 3: THE FINAL ASCENT ---

            const finalPlat1 = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 4), platMat);
            finalPlat1.position.set(0, 6, -38);
            scene.add(finalPlat1);
            platforms.push(finalPlat1);

            // Timed puzzle
            const timedPressurePlate = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), pressurePlateMat);
            timedPressurePlate.position.set(3, 7, -38);
            scene.add(timedPressurePlate);

            const timedDoorMesh = new THREE.Mesh(new THREE.BoxGeometry(4, 0.5, 4), movingPlatMat);
            const timedDoorStart = new THREE.Vector3(-6, 6, -38);
            const timedDoorEnd = new THREE.Vector3(-2, 6, -38);
            timedDoorMesh.position.copy(timedDoorStart);
            scene.add(timedDoorMesh);
            const timedDoorObject = { mesh: timedDoorMesh, startPos: timedDoorStart, endPos: timedDoorEnd };
            doors.push(timedDoorObject);
            platforms.push(timedDoorMesh);

            pressurePlates.push({ mesh: timedPressurePlate, linkedDoor: timedDoorObject, isPressed: false, timer: 5, countdown: 5 });

            // Final goal platform
            const goalPlat = new THREE.Mesh(new THREE.BoxGeometry(6, 1, 6), platMat);
            goalPlat.position.set(-8, 6, -38);
            scene.add(goalPlat);
            platforms.push(goalPlat);

            const fireDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), fireDoorMat);
            fireDoor.position.set(-9, 7.5, -38);
            scene.add(fireDoor);
            goals.push({ object: fireDoor, player: 0 });

            const waterDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), waterDoorMat);
            waterDoor.position.set(-7, 7.5, -38);
            scene.add(waterDoor);
            goals.push({ object: waterDoor, player: 1 });

            // --- COLLECTIBLES ---
            const gemData = [
                // Section 1
                { pos: new THREE.Vector3(-7, 1.5, -3), type: 'fire' },
                { pos: new THREE.Vector3(7, 1.5, -3), type: 'water' },
                { pos: new THREE.Vector3(-7, 1.5, -9), type: 'neutral' },
                { pos: new THREE.Vector3(7, 1.5, -9), type: 'neutral' },
                // Section 2
                { pos: new THREE.Vector3(0, 9.5, -25), type: 'fire' },
                { pos: new THREE.Vector3(0, 9.5, -25), type: 'water' },
                { pos: new THREE.Vector3(4, 10.5, -30), type: 'neutral' },
                // Section 3
                { pos: new THREE.Vector3(3, 8.5, -38), type: 'neutral' },
                { pos: new THREE.Vector3(-8, 7.5, -36), type: 'fire' },
                { pos: new THREE.Vector3(-8, 7.5, -40), type: 'water' },
            ];

            gemData.forEach(data => {
                const mat = data.type === 'fire' ? redGemMat : (data.type === 'water' ? blueGemMat : neutralGemMat);
                const gem = new THREE.Mesh(gemGeo, mat);
                gem.position.copy(data.pos);
                scene.add(gem);
                collectibles.push({ mesh: gem, type: data.type });
                if (data.type === 'fire') totalRedCollectibles++;
                else if (data.type === 'water') totalBlueCollectibles++;
                else totalNeutralCollectibles++;
            });
        }
    
        function buildCompetitionLevel() {
            clearLevel();
            const platMat = new THREE.MeshStandardMaterial({ color: 0x68d391 });
            const hazardBlueMat = new THREE.MeshStandardMaterial({ color: 0x3182ce });
            const hazardRedMat = new THREE.MeshStandardMaterial({ color: 0xe53e3e });
            const fireDoorMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const waterDoorMat = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const levelData = [
                { type: 'plat', size: [3, 1, 3], pos: [-6, 1, 0] }, { type: 'plat', size: [3, 1, 3], pos: [6, 1, 0] },
                { type: 'plat', size: [2, 1, 6], pos: [-6, 3, -8] }, { type: 'plat', size: [2, 1, 6], pos: [6, 3, -8] },
                { type: 'plat', size: [2, 1, 2], pos: [-3, 5, -15] }, { type: 'plat', size: [2, 1, 2], pos: [3, 5, -15] },
                { type: 'plat', size: [8, 1, 3], pos: [0, 7, -20] },
                { type: 'hazard', mat: hazardRedMat, size: [2, 0.5, 2], pos: [-6, 3.75, -6], player: 1 }, // Harmful to Watergirl
                { type: 'hazard', mat: hazardBlueMat, size: [2, 0.5, 2], pos: [6, 3.75, -6], player: 0 }, // Harmful to Fireboy
                { type: 'goal', mat: fireDoorMat, size: [1.5, 3, 1.5], pos: [-1.5, 8.5, -20], player: 0 }, // Fireboy's goal
                { type: 'goal', mat: waterDoorMat, size: [1.5, 3, 1.5], pos: [1.5, 8.5, -20], player: 1 }  // Watergirl's goal
            ];
            levelData.forEach(data => {
                const mat = data.mat || platMat;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(...data.size), mat);
                mesh.position.set(...data.pos);
                scene.add(mesh);
                if (data.type === 'plat') platforms.push(mesh);
                else if (data.type === 'hazard') hazards.push({ object: mesh, harmfulTo: data.player });
                else if (data.type === 'goal') goals.push({ object: mesh, player: data.player });
            });

            // NEW: Add collectibles for competition
            const redGemMat = new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0xff5555, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const blueGemMat = new THREE.MeshStandardMaterial({ color: 0x5599ff, emissive: 0x5599ff, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const neutralGemMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, emissive: 0xcccccc, emissiveIntensity: 0.5, metalness: 0.9, roughness: 0.1 });
            const gemGeo = new THREE.OctahedronGeometry(0.3, 0);
            const gemData = [
                { pos: [-6, 2, -4], type: 'fire' }, { pos: [6, 2, -4], type: 'water' },
                { pos: [-6, 4, -12], type: 'fire' }, { pos: [6, 4, -12], type: 'water' },
            ];
            gemData.forEach(data => {
                const mat = data.type === 'fire' ? redGemMat : (data.type === 'water' ? blueGemMat : neutralGemMat);
                const gem = new THREE.Mesh(gemGeo, mat);
                gem.position.set(...data.pos);
                scene.add(gem);
                collectibles.push({ mesh: gem, type: data.type });
                if (data.type === 'fire') {
                    totalRedCollectibles++;
                } else if (data.type === 'water') {
                    totalBlueCollectibles++;
                } else {
                    totalNeutralCollectibles++;
                }
            });
        }
    
        function getPlayerBounds(player) {
            return {
                minX: player.position.x - 0.5, maxX: player.position.x + 0.5,
                minY: player.position.y, maxY: player.position.y + 1.8, // Feet at y=0, height is 1.8
                minZ: player.position.z - 0.5, maxZ: player.position.z + 0.5
            };
        }
    
        function getObjectBounds(object) {
            if (object === floor) return { minX: -60, maxX: 60, minY: -0.1, maxY: 0.1, minZ: -60, maxZ: 60 };
            const box = new THREE.Box3().setFromObject(object);
            return {
                minX: box.min.x, maxX: box.max.x,
                minY: box.min.y, maxY: box.max.y,
                minZ: box.min.z, maxZ: box.max.z
            };
        }

        function checkCollision(bounds1, bounds2) {
            return bounds1.minX < bounds2.maxX && bounds1.maxX > bounds2.minX &&
                   bounds1.minY < bounds2.maxY && bounds1.maxY > bounds2.minY &&
                   bounds1.minZ < bounds2.maxZ && bounds1.maxZ > bounds2.minZ;
        }

        function updatePressurePlates() {
            const delta = 1 / 60; // Assuming 60 FPS
            pressurePlates.forEach(plate => {
                let isObjectOnPlate = false;
                for (const player of players) {
                    if (checkCollision(getPlayerBounds(player.object), getObjectBounds(plate.mesh))) {
                        isObjectOnPlate = true;
                        break;
                    }
                }
                if (!isObjectOnPlate) {
                    for (const pushable of pushableObjects) {
                        if (checkCollision(getObjectBounds(pushable.mesh), getObjectBounds(plate.mesh))) {
                            isObjectOnPlate = true;
                            break;
                        }
                    }
                }

                const door = plate.linkedDoor;
                if (isObjectOnPlate) {
                    if (!plate.isPressed) {
                        plate.isPressed = true;
                        if (plate.timer) plate.countdown = plate.timer;
                        const index = platforms.indexOf(door.mesh);
                        if (index > -1) {
                            platforms.splice(index, 1);
                        }
                    }
                } else {
                    if (plate.isPressed) {
                        if (plate.timer) {
                            plate.countdown -= delta;
                            if (plate.countdown <= 0) {
                                plate.isPressed = false;
                                if (!platforms.includes(door.mesh)) {
                                    platforms.push(door.mesh);
                                }
                            }
                        } else {
                            plate.isPressed = false;
                            if (!platforms.includes(door.mesh)) {
                                platforms.push(door.mesh);
                            }
                        }
                    }
                }

                const target = plate.isPressed ? door.endPos : door.startPos;
                door.mesh.position.lerp(target, 0.05);
            });
        }

        function updateDualPressurePlates() {
            dualPressurePlates.forEach(plate => {
                const plateBounds = getObjectBounds(plate.mesh);
                
                // Check each player
                plate.player1On = checkCollision(getPlayerBounds(players[0].object), plateBounds);
                plate.player2On = checkCollision(getPlayerBounds(players[1].object), plateBounds);

                const bothPlayersOn = plate.player1On && plate.player2On;
                const door = plate.linkedDoor;

                if (bothPlayersOn) {
                    if (!plate.isPressed) {
                        plate.isPressed = true;
                        // Door is opening, remove from collision
                        const index = platforms.indexOf(door.mesh);
                        if (index > -1) {
                            platforms.splice(index, 1);
                        }
                        plate.mesh.material.emissive.setHex(0xffffff); // Glow when active
                    }
                } else {
                    if (plate.isPressed) {
                        plate.isPressed = false;
                        // Door is closing, add back to collision
                        if (!platforms.includes(door.mesh)) {
                           platforms.push(door.mesh);
                        }
                        plate.mesh.material.emissive.setHex(0x9f7aea); // Revert emissive color
                    }
                }

                // Move door based on plate state
                const target = plate.isPressed ? door.endPos : door.startPos;
                door.mesh.position.lerp(target, 0.05);
            });
        }

        function updatePushableObjects() {
            const friction = 0.95; // How quickly objects slow down

            pushableObjects.forEach(obj => {
                const oldPos = obj.mesh.position.clone();
                // Apply gravity
                obj.velocity.y += gravity;
                obj.mesh.position.y += obj.velocity.y;

                // Apply friction based on mass (heavier objects have more friction/slow down faster)
                const effectiveFriction = Math.pow(friction, obj.mass || 1);
                obj.velocity.x *= effectiveFriction;
                obj.velocity.z *= effectiveFriction;

                // Collision with platforms
                obj.isGrounded = false;
                let objBounds = getObjectBounds(obj.mesh);

                for (const platform of platforms) {
                    if (platform === obj.mesh) continue; // Don't collide with self
                    const platformBounds = getObjectBounds(platform);
                    if (checkCollision(objBounds, platformBounds)) {
                        if (obj.velocity.y <= 0) { // Falling onto a platform
                            obj.mesh.position.y = platformBounds.maxY + (objBounds.maxY - objBounds.minY) / 2;
                            obj.velocity.y = 0;
                            obj.isGrounded = true;
                        } else { // Hitting a platform from below
                            obj.mesh.position.y = platformBounds.minY - (objBounds.maxY - objBounds.minY) / 2;
                            obj.velocity.y = 0;
                        }
                        break; // Stop after first collision
                    }
                }

                // Move based on horizontal velocity and check for wall collisions
                const originalX = obj.mesh.position.x;
                const originalZ = obj.mesh.position.z;
                obj.mesh.position.x += obj.velocity.x;
                obj.mesh.position.z += obj.velocity.z;

                objBounds = getObjectBounds(obj.mesh);
                for (const platform of platforms) {
                    if (platform === floor || platform === obj.mesh) continue; // Don't collide with self or floor
                    const platformBounds = getObjectBounds(platform);
                    if (checkCollision(objBounds, platformBounds) && objBounds.minY < platformBounds.maxY) {
                        // A simple bounce-back effect
                        obj.mesh.position.x = originalX;
                        obj.mesh.position.z = originalZ;
                        obj.velocity.x *= -0.5;
                        obj.velocity.z *= -0.5;
                        break;
                    }
                }

                // Calculate the actual velocity for this frame to carry the player
                obj.frameVelocity.subVectors(obj.mesh.position, oldPos);
            });
        }

        function updateInteractiveObjects() {
            movingPlatforms.forEach(p => {
                const oldPos = p.mesh.position.clone();
                let target;

                if (p.isActive) {
                    if (p.currentTargetIndex >= p.waypoints.length) {
                        p.currentTargetIndex = p.waypoints.length - 1;
                    }
                    target = p.waypoints[p.currentTargetIndex];
                    if (p.mesh.position.distanceTo(target) < 0.05) {
                        if (p.currentTargetIndex < p.waypoints.length - 1) {
                            p.currentTargetIndex++;
                        }
                    }
                } else {
                    target = p.waypoints[0];
                    if (p.mesh.position.distanceTo(target) < 0.05) {
                        p.currentTargetIndex = 1;
                    }
                }
                p.mesh.position.lerp(target, p.speed);
                p.velocity.subVectors(p.mesh.position, oldPos);
            });

            levers.forEach(lever => {
                if (lever.linkedObject && lever.linkedObject.door) {
                    const door = lever.linkedObject.door;
                    const target = lever.activated ? door.endPos : door.startPos;
                    door.mesh.position.lerp(target, 0.05);

                    if (lever.activated) {
                        const index = platforms.indexOf(door.mesh);
                        if (index > -1) {
                            platforms.splice(index, 1);
                        }
                    } else {
                        if (!platforms.includes(door.mesh)) {
                           platforms.push(door.mesh);
                        }
                    }
                }
            });

            pushers.forEach(pusher => {
                const oldPos = pusher.mesh.position.clone();
                const target = pusher.direction === 1 ? pusher.endPos : pusher.startPos;
                if (pusher.mesh.position.distanceTo(target) < 0.1) {
                    pusher.direction *= -1;
                }
                const moveDirection = new THREE.Vector3().subVectors(target, pusher.mesh.position).normalize();
                pusher.mesh.position.add(moveDirection.multiplyScalar(pusher.speed));
                pusher.velocity.subVectors(pusher.mesh.position, oldPos);
            });
        }

        function updatePlayer(playerData, playerIndex) {
            const player = playerData.object;
            const controls = playerData.controls;
            if (keys[controls.left]) player.rotation.y += playerRotationSpeed;
            if (keys[controls.right]) player.rotation.y -= playerRotationSpeed;

            // --- Animation Logic ---
            const animParts = player.userData.anim;

            if (keys[controls.interact]) {
                for (const lever of levers) {
                    if (player.position.distanceTo(lever.mesh.position) < 2.5) {
                        lever.activated = !lever.activated;
                        lever.handleMesh.rotation.z = lever.activated ? Math.PI / 4 : -Math.PI / 4;
                        if (lever.linkedObject && 'isActive' in lever.linkedObject) {
                            lever.linkedObject.isActive = lever.activated;
                        }
                        break;
                    }
                }
                keys[controls.interact] = false;
            }
            const isMoving = (keys[controls.forward] || keys[controls.back]) && playerData.isGrounded;

            if (playerData.isGrounded) {
                // On the ground: either walking or returning to idle
                if (isMoving) {
                    // Walking animation
                    playerData.walkPhase += 0.2; // Animation speed
                    const walkCycle = Math.sin(playerData.walkPhase);
                    const bobble = Math.abs(walkCycle) * 0.05; // Body bob
                    animParts.body.position.y = 0.8 + bobble;
                    animParts.headGroup.position.y = 1.5 + bobble;
                    animParts.armL.rotation.x = walkCycle * 0.8;
                    animParts.armR.rotation.x = -walkCycle * 0.8;
                    animParts.legL.rotation.x = -walkCycle * 1.0;
                    animParts.legR.rotation.x = walkCycle * 1.0;
                } else {
                    // Idle animation (smoothly return to base pose from walking or jumping)
                    playerData.walkPhase = 0;
                    animParts.body.position.y = THREE.MathUtils.lerp(animParts.body.position.y, 0.8, 0.1);
                    animParts.headGroup.position.y = THREE.MathUtils.lerp(animParts.headGroup.position.y, 1.5, 0.1);
                    animParts.armL.rotation.x = THREE.MathUtils.lerp(animParts.armL.rotation.x, 0, 0.1);
                    animParts.armR.rotation.x = THREE.MathUtils.lerp(animParts.armR.rotation.x, 0, 0.1);
                    animParts.legL.rotation.x = THREE.MathUtils.lerp(animParts.legL.rotation.x, 0, 0.1);
                    animParts.legR.rotation.x = THREE.MathUtils.lerp(animParts.legR.rotation.x, 0, 0.1);
                }
            } else {
                // In the air: jump/fall animation
                playerData.walkPhase = 0;
                animParts.body.position.y = THREE.MathUtils.lerp(animParts.body.position.y, 0.7, 0.1);
                animParts.headGroup.position.y = THREE.MathUtils.lerp(animParts.headGroup.position.y, 1.4, 0.1);
                animParts.armL.rotation.x = THREE.MathUtils.lerp(animParts.armL.rotation.x, -0.5, 0.1);
                animParts.armR.rotation.x = THREE.MathUtils.lerp(animParts.armR.rotation.x, -0.5, 0.1);
                animParts.legL.rotation.x = THREE.MathUtils.lerp(animParts.legL.rotation.x, 0.8, 0.1);
                animParts.legR.rotation.x = THREE.MathUtils.lerp(animParts.legR.rotation.x, 0.8, 0.1);
            }

            const moveDirection = new THREE.Vector3();
            if (keys[controls.forward]) moveDirection.z = -1;
            if (keys[controls.back]) moveDirection.z = 1;
            moveDirection.applyQuaternion(player.quaternion).multiplyScalar(playerSpeed);
            const originalX = player.position.x;
            const originalZ = player.position.z;
            player.position.x += moveDirection.x;
            player.position.z += moveDirection.z;

            // --- Horizontal Collision and Pushing Logic ---
            let playerBounds = getPlayerBounds(player);
            let collisionOccurred = false;

            // 1. Check for collisions with pushable objects
            for (const pushable of pushableObjects) {
                if (checkCollision(playerBounds, getObjectBounds(pushable.mesh))) {
                    const pushDirection = new THREE.Vector3().subVectors(pushable.mesh.position, player.position);
                    pushDirection.y = 0;
                    pushDirection.normalize();
                    const basePushStrength = 0.05;
                    const effectivePushStrength = basePushStrength / (pushable.mass || 1);
                    pushable.velocity.add(pushDirection.multiplyScalar(effectivePushStrength));
                    // Player is stopped by the object they are pushing
                    player.position.set(originalX, player.position.y, originalZ);
                    collisionOccurred = true;
                    break; 
                }
            }

            // 2. If no pushable was hit, check for static walls
            if (!collisionOccurred) {
                for (const platform of platforms) {
                    const isPushable = pushableObjects.some(p => p.mesh === platform);
                    if (platform === floor || isPushable) continue; // Ignore floor and objects we already handled
                    const platformBounds = getObjectBounds(platform);
                    if (checkCollision(playerBounds, platformBounds) && playerBounds.minY < platformBounds.maxY + 0.1) {
                        player.position.set(originalX, player.position.y, originalZ);
                        break;
                    }
                }
            }

            if (keys[controls.jump] && playerIndex === 0 && playerData.isGrounded) {
                playerData.isGrounded = false;
                playerData.velocityY = jumpHeight;
                jumpFbSound.play();
            }
            if (keys[controls.jump] && playerIndex === 1 && playerData.isGrounded) {
                playerData.isGrounded = false;
                playerData.velocityY = jumpHeight;
                jumpWgSound.play();
            }
            playerData.velocityY += gravity;
            player.position.y += playerData.velocityY;
            playerData.groundedOn = null; // Reset before checking
            playerData.isGrounded = false;
            let newPlayerBounds = getPlayerBounds(player);
            for (const platform of platforms) {
                const platformBounds = getObjectBounds(platform);
                if (checkCollision(newPlayerBounds, platformBounds)) {
                    if (playerData.velocityY <= 0) {
                        playerData.groundedOn = platform; // Store which platform we're on
                        player.position.y = platformBounds.maxY;
                        playerData.velocityY = 0;
                        playerData.isGrounded = true;
                    } else {
                        player.position.y = platformBounds.minY - 1.8;
                        playerData.velocityY = 0;
                    }
                    break;
                }
            }
            if (player.position.y < -20) {
                player.position.copy(playerData.spawnPoint);
                playerData.velocityY = 0;
                playerData.isGrounded = true;
            }

            // NEW: Stick to moving platform
            if (playerData.isGrounded && playerData.groundedOn) {
                const movingPlatform = movingPlatforms.find(p => p.mesh === playerData.groundedOn);
                if (movingPlatform) {
                    player.position.add(movingPlatform.velocity);
                }
                const pushableObject = pushableObjects.find(p => p.mesh === playerData.groundedOn);
                if (pushableObject) {
                    // Move player with the pushable object
                    player.position.add(pushableObject.frameVelocity);
                }
            }

            // NEW: Pusher collision
            for (const pusher of pushers) {
                if (checkCollision(getPlayerBounds(player), getObjectBounds(pusher.mesh))) {
                    player.position.add(pusher.velocity);
                }
            }

            // MODIFIED: Hazard check now runs for both modes
            for (const hazard of hazards) {
                if (hazard.harmfulTo === playerIndex && checkCollision(getPlayerBounds(player), getObjectBounds(hazard.object))) {
                    player.position.copy(playerData.spawnPoint);
                    playerData.velocityY = 0;
                    playerData.isGrounded = true;
                }
            }

            // NEW: Collectible collision check
            const playerBoundsForCollect = getPlayerBounds(player);
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const gemData = collectibles[i];
                const gem = gemData.mesh;
                // A player can collect their own color OR a neutral gem
                const canCollect = (playerData.type === gemData.type) || (gemData.type === 'neutral');

                if (canCollect && checkCollision(playerBoundsForCollect, getObjectBounds(gem))) {
                    scene.remove(gem);
                    collectibles.splice(i, 1);
                    if (gemData.type === 'fire') {
                        redCollectedCount++;
                    } else if (gemData.type === 'water') {
                        blueCollectedCount++;
                    } else { // Neutral gem
                        neutralCollectedCount++;
                    }
                    updateGemUI();
                    if (collectSound.isPlaying) collectSound.stop();
                    collectSound.play();
                }
            }
            // Competition-specific goal check
            if (gameMode === 'competition') {
                for (const goal of goals) {
                    if (goal.player === playerIndex && !raceFinished) {
                        const allOwnGemsCollected = (playerData.type === 'fire' && redCollectedCount >= totalRedCollectibles) ||
                                                    (playerData.type === 'water' && blueCollectedCount >= totalBlueCollectibles);
                        const allNeutralGemsCollected = neutralCollectedCount >= totalNeutralCollectibles;

                        if (allOwnGemsCollected && allNeutralGemsCollected && checkCollision(getPlayerBounds(player), getObjectBounds(goal.object))) {
                            raceFinished = true;
                            endGame(playerIndex);
                        }
                    }
                }
            }
        }
    
        function updateCheckpoints() {
            if (gameMode !== 'teamwork') return;
            const player1Bounds = getPlayerBounds(players[0].object);
            const player2Bounds = getPlayerBounds(players[1].object);
            for (const checkpoint of checkpoints) {
                if (checkpoint.activated) continue;
                const door1Bounds = getObjectBounds(checkpoint.pair[0]);
                const door2Bounds = getObjectBounds(checkpoint.pair[1]);
                // For teamwork checkpoints, player 1 (Fireboy) must be on the red door, player 2 (Watergirl) on the blue
                if (checkCollision(player1Bounds, door1Bounds) && checkCollision(player2Bounds, door2Bounds)) {
                    checkpoint.activated = true;
                    const spawnPoint = checkpoint.spawnPoint;
                    players[0].spawnPoint.copy(spawnPoint);
                    players[1].spawnPoint.copy(spawnPoint);
                    highestLevelUnlocked = Math.max(highestLevelUnlocked, 1);
                    checkpoint.pair[0].material.color.set(0x68d391);
                    checkpoint.pair[1].material.color.set(0x68d391);
                    saveProgress();
                }
            }
        }
        
        // NEW: Function to check for the teamwork win condition
        function checkTeamworkWin() {
            const allGemsCollected = redCollectedCount >= totalRedCollectibles &&
                                     blueCollectedCount >= totalBlueCollectibles &&
                                     neutralCollectedCount >= totalNeutralCollectibles;
            if (gameMode !== 'teamwork' || raceFinished || goals.length < 2 || !allGemsCollected) return;

            const fireboyGoal = goals.find(g => g.player === 0)?.object;
            const watergirlGoal = goals.find(g => g.player === 1)?.object;

            if (!fireboyGoal || !watergirlGoal) return;

            const player1Bounds = getPlayerBounds(players[0].object);
            const player2Bounds = getPlayerBounds(players[1].object);

            const fireboyAtGoal = checkCollision(player1Bounds, getObjectBounds(fireboyGoal));
            const watergirlAtGoal = checkCollision(player2Bounds, getObjectBounds(watergirlGoal));

            if (fireboyAtGoal && watergirlAtGoal) {
                raceFinished = true;
                // Make doors solid green to show completion
                fireboyGoal.material.color.set(0x28a745);
                fireboyGoal.material.emissive.set(0x28a745);
                watergirlGoal.material.color.set(0x28a745);
                watergirlGoal.material.emissive.set(0x28a745);
                endGame(); // No specific winner in teamwork
            }
        }

        function updateGemUI() {
            if (!player1GemUI || !player2GemUI) return;

            const neutralGemText = totalNeutralCollectibles > 0 ? `<br>Neutral: <span style="color: #cccccc;">${neutralCollectedCount} / ${totalNeutralCollectibles}</span>` : '';

            // Fireboy's UI (Player 1) - always shows red gem progress
            player1GemUI.innerHTML = `Gems: <span style="color: #ff5555;">${redCollectedCount} / ${totalRedCollectibles}</span>` + neutralGemText;
            
            // Watergirl's UI (Player 2) - always shows blue gem progress
            player2GemUI.innerHTML = `Gems: <span style="color: #5599ff;">${blueCollectedCount} / ${totalBlueCollectibles}</span>` + neutralGemText;
        }

        function endGame(winnerIndex) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (SurvivalMusic.isPlaying) {
                SurvivalMusic.stop();
            }
            if (CompetitionMusic.isPlaying) {
                CompetitionMusic.stop();
            }
            gameState = 'winner';
            
            if (gameMode === 'competition') {
                winnerText.textContent = `${players[winnerIndex].name} Wins!`;
                winnerSubtext.textContent = `First to the finish line!`;
                raceAgainButton.textContent = "Race Again";
            } else {
                winnerText.textContent = `Level Complete!`;
                winnerSubtext.textContent = `You reached the goal together!`;
                raceAgainButton.textContent = "Play Again"; // Or "Next Level" in the future
            }
            showScreen('winner-screen');
        }
    
        function startCountdown() {
            let count = 3;
            countdown.textContent = count;
            countdown.classList.remove('hidden');
            const interval = setInterval(() => {
                count--;
                countdown.textContent = count > 0 ? count : 'GO!';
                if (count <= -1) {
                    clearInterval(interval);
                    countdown.classList.add('hidden');
                    gameState = 'playing';
                    animate();
                }
            }, 1000);
        }
    
        let cameraOffset = new THREE.Vector3(0, 5, 8);
        const smoothness = 0.05;
        function updateCamera(camera, player) {
            // 1. Calculate the ideal camera position as before
            const idealOffset = cameraOffset.clone().applyQuaternion(player.quaternion);
            let targetPosition = player.position.clone().add(idealOffset);

            // 2. Check for collisions between the player and the camera
            const playerHead = player.position.clone().add(new THREE.Vector3(0, 1, 0)); // Raycast from near player's head
            const direction = targetPosition.clone().sub(playerHead).normalize();
            const distance = playerHead.distanceTo(targetPosition);
            const raycaster = new THREE.Raycaster(playerHead, direction, 0, distance);

            const intersects = raycaster.intersectObjects(platforms, false); // Don't check children

            if (intersects.length > 0) {
                // If the ray hits a platform, move the camera to the intersection point
                // instead of its ideal position behind the wall.
                targetPosition = intersects[0].point.clone().sub(direction.multiplyScalar(0.5)); // Pull back slightly from the wall
            }

            // 3. Smoothly move and look at the player as before
            camera.position.lerp(targetPosition, smoothness);
            const lookAtTarget = player.position.clone();
            lookAtTarget.y += 0.5;
            camera.lookAt(lookAtTarget);
        }

        function animate() {
            if (gameState !== 'playing' && gameState !== 'paused') return;
            animationFrameId = requestAnimationFrame(animate);
    
            if (gameState === 'playing') {
                // NEW: Animate collectibles
                collectibles.forEach(gemData => {
                    gemData.mesh.rotation.y += 0.02;
                });
                updateInteractiveObjects();
                updatePressurePlates();
                updatePushableObjects();
                updateDualPressurePlates();
                players.forEach((player, index) => updatePlayer(player, index));
                updateCheckpoints();
                checkTeamworkWin(); // NEW
            }
    
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            renderer.setScissorTest(true);
            renderer.setScissor(0, 0, screenWidth / 2, screenHeight);
            renderer.setViewport(0, 0, screenWidth / 2, screenHeight);
            updateCamera(camera1, players[0].object);
            renderer.render(scene, camera1);
            renderer.setScissor(screenWidth / 2, 0, screenWidth / 2, screenHeight);
            renderer.setViewport(screenWidth / 2, 0, screenWidth / 2, screenHeight);
            updateCamera(camera2, players[1].object);
            renderer.render(scene, camera2);
            renderer.setScissorTest(false);
        }
    
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera1.aspect = (width / 2) / height;
            camera1.updateProjectionMatrix();
            camera2.aspect = (width / 2) / height;
            camera2.updateProjectionMatrix();
        });
    
        function showScreen(screenId) {
            mainMenu.classList.add('hidden');
            submenu.classList.add('hidden');
            gameContainer.classList.add('hidden');
            confirmationDialog.classList.add('hidden');
            winnerScreen.classList.add('hidden');
            document.getElementById(screenId)?.classList.remove('hidden');
        }
    
        function resetPlayerAnimation(playerData) {
            const animParts = playerData.object.userData.anim;
            if (!animParts) return;
            playerData.walkPhase = 0;
            animParts.body.position.y = 0.8;
            animParts.headGroup.position.y = 1.5;
            animParts.armL.rotation.set(0, 0, 0);
            animParts.armR.rotation.set(0, 0, 0);
            animParts.legL.rotation.set(0, 0, 0);
            animParts.legR.rotation.set(0, 0, 0);
        }

        function resetLevelState(isNewGame) {
            raceFinished = false;
            const defaultSpawn1 = new THREE.Vector3(-2, 0.5, 0);
            const defaultSpawn2 = new THREE.Vector3(2, 0.5, 0);
            redCollectedCount = 0;
            blueCollectedCount = 0;
            neutralCollectedCount = 0;
    
            if (gameMode === 'competition') {
                players[0].spawnPoint.set(-6, 1.5, 2);
                players[1].spawnPoint.set(6, 1.5, 2);
            } else { // Teamwork
                let p1Spawn = isNewGame || !savedSpawnPoint ? defaultSpawn1 : new THREE.Vector3().copy(savedSpawnPoint);
                let p2Spawn = isNewGame || !savedSpawnPoint ? defaultSpawn2 : new THREE.Vector3().copy(savedSpawnPoint);
                players[0].spawnPoint.copy(p1Spawn);
                players[1].spawnPoint.copy(p2Spawn);
            }

            players.forEach(p => {
                p.object.position.copy(p.spawnPoint);
                p.velocityY = 0;
                p.isGrounded = true;
                p.groundedOn = null;
                resetPlayerAnimation(p);
            });
        }
    
        function updateSubmenuButtons() {
            if (hasSavedProgress) {
                resumeGameButton.classList.remove('hidden');
                newGameButton.classList.remove('hidden');
                startGameButton.classList.add('hidden');
            } else {
                resumeGameButton.classList.add('hidden');
                newGameButton.classList.add('hidden');
                startGameButton.classList.remove('hidden');
            }
        }
    
        function startGame(mode, isResume = false) {
            // Resume audio context on user interaction - this is crucial for browsers
            if (listener1.context.state === 'suspended') {
                listener1.context.resume();
            }

            gameMode = mode;
            if (mode === 'teamwork') {
                if (CompetitionMusic.isPlaying) CompetitionMusic.stop();
                buildTeamworkLevel();
                if (!SurvivalMusic.isPlaying) {
                    SurvivalMusic.play();
                    SurvivalMusic.setLoop(true);
                }
            } else if (mode === 'competition') {
                if (SurvivalMusic.isPlaying) SurvivalMusic.stop();
                buildCompetitionLevel();
                if (!CompetitionMusic.isPlaying) {
                    CompetitionMusic.play();
                    CompetitionMusic.setLoop(true);
                }
            }
    
            resetLevelState(!isResume);
            updateGemUI();
            showScreen('game-container');
    
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
    
            if (mode === 'competition') {
                gameState = 'countdown';
                startCountdown();
            } else {
                gameState = 'playing';
                animate();
            }
        }
    
        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseMenu.classList.remove('hidden');
                if (gameMode === 'teamwork' && SurvivalMusic.isPlaying) {
                    SurvivalMusic.pause();
                }
                if (gameMode === 'competition' && CompetitionMusic.isPlaying) {
                    CompetitionMusic.pause();
                }
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseMenu.classList.add('hidden');
                if (gameMode === 'teamwork') {
                    SurvivalMusic.play();
                }
                if (gameMode === 'competition') {
                    CompetitionMusic.play();
                }
            }
        }
    
        function returnToMenu() {
            if (gameMode === 'teamwork') {
                saveProgress();
            }
            if (SurvivalMusic.isPlaying) {
                SurvivalMusic.stop();
            }
            if (CompetitionMusic.isPlaying) {
                CompetitionMusic.stop();
            }
            pauseMenu.classList.add('hidden');
            showScreen('main-menu');
            gameState = 'menu';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
    
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'p' && (gameState === 'playing' || gameState === 'paused')) {
                togglePause();
            }
        });
    
        // --- EVENT LISTENERS ---
        resumeButton.addEventListener('click', togglePause);
        restartCheckpointButton.addEventListener('click', () => {
            // Reset players to their last checkpoint
            players.forEach(p => {
                p.object.position.copy(p.spawnPoint);
                p.velocityY = 0;
                p.isGrounded = true;
            });
            // Reset pushable objects to their initial positions
            pushableObjects.forEach(obj => {
                obj.mesh.position.copy(obj.startPos);
                obj.velocity.set(0, 0, 0);
                obj.frameVelocity.set(0, 0, 0);
            });
            if(gameState === 'paused') togglePause();
        });
        returnToMenuButton.addEventListener('click', returnToMenu);
        teamworkButton.addEventListener('click', () => {
            gameMode = 'teamwork';
            loadProgress();
            updateSubmenuButtons();
            showScreen('submenu');
        });
        competitionButton.addEventListener('click', () => startGame('competition', false));
        backToMainButton.addEventListener('click', () => showScreen('main-menu'));
        resumeGameButton.addEventListener('click', () => startGame('teamwork', true));
        startGameButton.addEventListener('click', () => startGame('teamwork', false));
        newGameButton.addEventListener('click', () => showScreen('confirmation-dialog'));
        confirmYesButton.addEventListener('click', () => {
            localStorage.removeItem('3dup-up_progress');
            localStorage.removeItem('3dup-up_spawnPoint');
            hasSavedProgress = false;
            savedSpawnPoint = null;
            startGame('teamwork', false);
        });
        confirmNoButton.addEventListener('click', () => showScreen('submenu'));
        raceAgainButton.addEventListener('click', () => {
            if (gameMode === 'competition') {
                startGame('competition', false);
            } else {
                startGame('teamwork', false);
            }
        });
        backToMenuButton.addEventListener('click', () => {
            showScreen('main-menu');
            gameState = 'menu';
        });
    
        // Initialize on load
        loadProgress();
    </script>
</body>
</html>