<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D FireBoy & WaterGirl</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a202c; }
        canvas { display: block; }
        .hidden { display: none !important; }
        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; color: white; font-family: 'Press Start 2P', monospace;
            text-align: center;
        }
        .menu-screen h1 { font-size: 5rem; color: #4299e1; text-shadow: 4px 4px 0px #2b6cb0; margin-bottom: 3rem; }
        #mode-select { display: flex; gap: 2rem; }
        .mode-button {
            font-family: 'Press Start 2P', monospace; font-size: 1.5rem;
            padding: 1rem 2rem; border: 4px solid; cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .mode-button:hover { transform: scale(1.1); }
        #teamwork-button { border-color: #f6e05e; background-color: #ecc94b; color: #975a16; }
        #teamwork-button:hover { box-shadow: 0 0 20px #f6e05e; }
        #competition-button { border-color: #f56565; background-color: #e53e3e; color: #742a2a; }
        #competition-button:hover { box-shadow: 0 0 20px #f56565; }
        #game-container { position: relative; }
        #split-border {
            position: absolute; left: 50%; top: 0; bottom: 0;
            width: 4px; background-color: #ecf0f1;
            transform: translateX(-50%); pointer-events: none;
        }
        .menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); display: flex;
            justify-content: center; align-items: center; font-family: 'Press Start 2P', monospace;
        }
        .menu-box {
            background-color: #2d3748; padding: 2rem 3rem; border-radius: 10px;
            border: 4px solid #4a5568; text-align: center; color: white;
        }
        .menu-box h1 { font-size: 2.5rem; margin-bottom: 2rem; }
        .menu-box button {
            font-family: 'Press Start 2P', monospace; font-size: 1rem;
            padding: 0.8rem 1.5rem; border: 3px solid; cursor: pointer;
            transition: all 0.2s ease-in-out; display: block;
            width: 100%; margin-bottom: 1rem;
        }
        .menu-box button:last-child { margin-bottom: 0; }
        .menu-box p { margin-bottom: 1.5rem; }
        .menu-box button:disabled { background-color: #4a5568; border-color: #2d3748; color: #718096; cursor: not-allowed; }
        .menu-box button:disabled:hover { transform: none; }
        #winner-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; font-family: 'Press Start 2P', monospace;
            text-align: center; color: white;
        }
        #winner-screen h1 { font-size: 4rem; margin-bottom: 2rem; text-shadow: 4px 4px 0px rgba(0,0,0,0.5); animation: pulse 2s infinite; }
        #winner-screen p { font-size: 1.5rem; margin-bottom: 3rem; opacity: 0.8; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
        #countdown {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', monospace; font-size: 8rem; color: #f56565;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5); z-index: 1000; pointer-events: none;
        }
        .gem-ui {
            position: absolute;
            top: 20px;
            font-family: 'Press Start 2P', monospace;
            color: white;
            font-size: 1rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }
        #player1-gem-ui { left: 20px; }
        #player2-gem-ui { left: calc(50% + 20px); }
    </style>
</head>
<body>
    <div id="main-menu" class="menu-screen">
        <h1>3D FireBoy & WaterGirl</h1>
        <div id="mode-select">
            <button id="teamwork-button" class="mode-button">Survival Mode</button>
            <button id="competition-button" class="mode-button">1 vs 1</button>
        </div>
    </div>
    <div id="submenu" class="menu-screen hidden">
        <div class="menu-box">
            <h1>Survival Mode</h1>
            <button id="resume-game-button">Resume Game</button>
            <button id="new-game-button">New Game</button>
            <button id="start-game-button" class="hidden">Start Game</button>
            <button id="back-to-main-button">Back</button>
        </div>
    </div>
    <div id="confirmation-dialog" class="menu-screen hidden">
        <div class="menu-box">
            <p>Start a new game?<br>All progress will be lost!</p>
            <button id="confirm-yes-button">Yes</button>
            <button id="confirm-no-button">No</button>
        </div>
    </div>
    <div id="winner-screen" class="hidden">
        <h1 id="winner-text">Player 1 Wins!</h1>
        <p id="winner-subtext">First to reach the finish line!</p>
        <div class="menu-box">
            <button id="race-again-button">Play Again</button>
            <button id="back-to-menu-button">Back to Menu</button>
        </div>
    </div>
    <div id="game-container" class="hidden">
        <div id="split-border"></div>
        <div id="countdown" class="hidden"></div>
        <div id="player1-gem-ui" class="gem-ui"></div>
        <div id="player2-gem-ui" class="gem-ui"></div>
        <div id="pause-menu" class="menu-overlay hidden">
            <div class="menu-box">
                <h1>Paused</h1>
                <button id="resume-button">Resume</button>
                <button id="restart-checkpoint-button">Restart from Checkpoint</button>
                <button id="return-to-menu-button">Return to Menu</button>
            </div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';
    
        // --- UI ELEMENTS ---
        const mainMenu = document.getElementById('main-menu');
        const submenu = document.getElementById('submenu');
        const teamworkButton = document.getElementById('teamwork-button');
        const competitionButton = document.getElementById('competition-button');
        const resumeGameButton = document.getElementById('resume-game-button');
        const newGameButton = document.getElementById('new-game-button');
        const startGameButton = document.getElementById('start-game-button');
        const backToMainButton = document.getElementById('back-to-main-button');
        const gameContainer = document.getElementById('game-container');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeButton = document.getElementById('resume-button');
        const restartCheckpointButton = document.getElementById('restart-checkpoint-button');
        const returnToMenuButton = document.getElementById('return-to-menu-button');
        const confirmationDialog = document.getElementById('confirmation-dialog');
        const confirmYesButton = document.getElementById('confirm-yes-button');
        const confirmNoButton = document.getElementById('confirm-no-button');
        const winnerScreen = document.getElementById('winner-screen');
        const winnerText = document.getElementById('winner-text');
        const winnerSubtext = document.getElementById('winner-subtext'); 
        const raceAgainButton = document.getElementById('race-again-button');
        const backToMenuButton = document.getElementById('back-to-menu-button');
        const countdown = document.getElementById('countdown');
        const player1GemUI = document.getElementById('player1-gem-ui');
        const player2GemUI = document.getElementById('player2-gem-ui');
    
        // --- GAME STATE ---
        let gameState = 'menu';
        let gameMode = 'none';
        let animationFrameId;
        let highestLevelUnlocked = 0;
        let hasSavedProgress = false;
        let savedSpawnPoint = null;
        let raceFinished = false;
        let totalRedCollectibles = 0;
        let totalBlueCollectibles = 0;
        let redCollectedCount = 0;
        let blueCollectedCount = 0;

    
        // --- SAVE/LOAD ---
        function loadProgress() {
            const savedLevel = localStorage.getItem('3dup-up_progress');
            const savedSpawn = localStorage.getItem('3dup-up_spawnPoint');
            if (savedLevel !== null) {
                highestLevelUnlocked = parseInt(savedLevel);
                hasSavedProgress = true;
            } else {
                highestLevelUnlocked = 0;
                hasSavedProgress = false;
            }
            if (savedSpawn) {
                savedSpawnPoint = JSON.parse(savedSpawn);
            } else {
                savedSpawnPoint = null;
            }
        }
    
        function saveProgress() {
            localStorage.setItem('3dup-up_progress', highestLevelUnlocked.toString());
            localStorage.setItem('3dup-up_spawnPoint', JSON.stringify(players[0].spawnPoint));
            hasSavedProgress = true;
        }
    
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a202c);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        gameContainer.appendChild(renderer.domElement);
        const camera1 = new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);
        const camera2 = new THREE.PerspectiveCamera(75, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);

        // --- GAME OBJECTS ---
        const platforms = [];
        const checkpoints = [];
        const hazards = [];
        const pressurePlates = [];
        const goals = [];
        const collectibles = [];
        // NEW: Player 1 (WASD) is now Fireboy (Red), Player 2 (Arrows) is Watergirl (Blue)
        const player1 = createPlayer(0xff3300, 'fire'); // Red
        scene.add(player1);
        const player2 = createPlayer(0x3366ff, 'water'); // Blue
        scene.add(player2);

        const players = [
            { object: player1, velocityY: 0, isGrounded: true, spawnPoint: new THREE.Vector3(-2, 0.5, 0), controls: { forward: 'w', back: 's', left: 'a', right: 'd', jump: ' ' }, type: 'fire', name: 'Fireboy', standingOnPlatform: null },
            { object: player2, velocityY: 0, isGrounded: true, spawnPoint: new THREE.Vector3(2, 0.5, 0), controls: { forward: 'arrowup', back: 'arrowdown', left: 'arrowleft', right: 'arrowright', jump: 'shift' }, type: 'water', name: 'Watergirl', standingOnPlatform: null }
        ];
        const floorGeometry = new THREE.PlaneGeometry(80, 80);
        // NEW: Floor material and mesh with color of real earth
        const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide });
        floorMaterial.map = new THREE.TextureLoader().load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
        floorMaterial.map.wrapS = THREE.RepeatWrapping;
        floorMaterial.map.wrapT = THREE.RepeatWrapping;
        floorMaterial.map.repeat.set(10, 10);
        floorMaterial.needsUpdate = true;
        floorMaterial.side = THREE.DoubleSide; // Ensure both sides are rendered
        floorMaterial.transparent = true; // Allow transparency for better visuals
        floorMaterial.opacity = 0.9; // Slightly transparent for a better look
        floorGeometry.computeVertexNormals(); // Ensure normals are correct for lighting
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
        platforms.push(floor);
        // very bright ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // --- AUDIO SETUP ---
        const listener1 = new THREE.AudioListener();
        camera1.add(listener1);
        const listener2 = new THREE.AudioListener();
        camera2.add(listener2);

        const audioLoader = new THREE.AudioLoader();
        const jumpFbSound = new THREE.Audio(listener1);
        const jumpWgSound = new THREE.Audio(listener2);
        const SurvivalMusic = new THREE.Audio(listener1);
        const CompetitionMusic = new THREE.Audio(listener1);
        const collectSound = new THREE.Audio(listener1);

        audioLoader.load('JumpFb.mp3', (buffer) => {
            jumpFbSound.setBuffer(buffer);
            jumpFbSound.setVolume(0.5);
        });
        audioLoader.load('JumpWg.mp3', (buffer) => {
            jumpWgSound.setBuffer(buffer);
            jumpWgSound.setVolume(0.5);
        });
        audioLoader.load('SurvivalMusic.mp3', (buffer) => {
            SurvivalMusic.setBuffer(buffer);
            SurvivalMusic.setVolume(0.5);
        });
        audioLoader.load('CompetitionMusic.mp3', (buffer) => {
            CompetitionMusic.setBuffer(buffer);
            CompetitionMusic.setVolume(0.5);
        });
        audioLoader.load('collect.mp3', (buffer) => { // You will need to add a 'collect.mp3' file
            collectSound.setBuffer(buffer);
            collectSound.setVolume(0.7);
        });

        // --- INPUT HANDLING ---
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        // --- CORE GAME LOGIC ---
        const playerSpeed = 0.1;
        const playerRotationSpeed = 0.05;
        const gravity = -0.015;
        const jumpHeight = 0.3;

        function createPlayer(color, type) {
    const playerGroup = new THREE.Group();

    // Materials
    const bodyMaterial = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.5 });
    const eyeWhiteMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc });
    const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

    // Head (Voxel structure)
    const headGroup = new THREE.Group();
    const headColor = (type === 'fire') ? 0xff3333 : 0x3399ff;

    const voxelMaterial = new THREE.MeshStandardMaterial({ color: headColor, emissive: headColor, emissiveIntensity: 0.4 });
    
    // Create voxel head as a grid of blocks
    for (let x = -1; x <= 1; x++) {
        for (let y = 0; y <= 2; y++) {
            for (let z = -1; z <= 1; z++) {
                if (Math.random() > 0.3 || y > 0) { // random blocky shape
                    const block = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), voxelMaterial);
                    block.position.set(x * 0.2, y * 0.2, z * 0.2);
                    headGroup.add(block);
                }
            }
        }
    }

    // Top flame or water bun
    if (type === 'fire') {
        for (let i = 0; i < 3; i++) {
            const flame = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), voxelMaterial);
            flame.position.set((i - 1) * 0.2, 0.7, 0);
            headGroup.add(flame);
        }
    } else {
        const bun = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), voxelMaterial);
        bun.position.set(0, 0.7, 0);
        headGroup.add(bun);
    }

    // Eyes
    const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.05), eyeWhiteMaterial);
    eyeL.position.set(-0.2, 0.4, 0.35);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.2;

    const pupilL = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.05), pupilMaterial);
    pupilL.position.set(-0.2, 0.4, 0.38);
    const pupilR = pupilL.clone();
    pupilR.position.x = 0.2;

    headGroup.add(eyeL, eyeR, pupilL, pupilR);
    headGroup.position.y = 1.5;
    // rotate head 180 degrees to face forward
    headGroup.rotation.y = Math.PI;

    // Body (simple block)
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.4), voxelMaterial);
    body.position.y = 0.8;

    // Arms
    const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), voxelMaterial);
    armL.position.set(-0.35, 1, 0);
    const armR = armL.clone();
    armR.position.x = 0.35;

    // Legs
    const legL = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.5, 0.2), voxelMaterial);
    legL.position.set(-0.15, 0.25, 0);
    const legR = legL.clone();
    legR.position.x = 0.15;

    // Light emission (optional glow)
    const glow = new THREE.PointLight(color, 1, 5);
    glow.position.y = 1.5;

    playerGroup.add(body, headGroup, armL, armR, legL, legR, glow);
    playerGroup.userData.anim = { headGroup, body, armL, armR, legL, legR };
    return playerGroup;
}

    
        function clearLevel() {
            for (let i = platforms.length - 1; i > 0; i--) scene.remove(platforms.pop());
            checkpoints.forEach(c => c.pair.forEach(door => scene.remove(door)));
            checkpoints.length = 0;
            hazards.forEach(h => scene.remove(h.object));
            hazards.length = 0;
            goals.forEach(g => scene.remove(g.object));
            goals.length = 0;
            collectibles.forEach(c => scene.remove(c.mesh));
            collectibles.length = 0;
            totalRedCollectibles = 0;
            totalBlueCollectibles = 0;
            redCollectedCount = 0;
            blueCollectedCount = 0;
        }
    
        function buildTeamworkLevel() {
            clearLevel();
            const platMat = new THREE.MeshStandardMaterial({ color: 0x68d391 });
            const plat1 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 4), platMat);
            plat1.position.set(-5, 2, 0);
            scene.add(plat1);
            platforms.push(plat1);
            const plat2 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), platMat);
            plat2.position.set(0, 4, -5);
            scene.add(plat2);
            platforms.push(plat2);
            const plat3 = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 8), platMat);
            plat3.position.set(5, 6, 0);
            scene.add(plat3);
            platforms.push(plat3);
            const plat4 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), platMat);
            plat4.position.set(5, 5, -10);
            scene.add(plat4);
            platforms.push(plat4);
            const cpMatB = new THREE.MeshStandardMaterial({ color: 0x00c6ff, transparent: true, opacity: 0.5 });
            const cpMatR = new THREE.MeshStandardMaterial({ color: 0xe74c3c, transparent: true, opacity: 0.5 });
            const cpDoor1 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.2), cpMatR);
            cpDoor1.position.set(-6, 3.5, 0);
            scene.add(cpDoor1);
            const cpDoor2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2, 0.2), cpMatB);
            cpDoor2.position.set(-4, 3.5, 0);
            scene.add(cpDoor2);
            checkpoints.push({ pair: [cpDoor1, cpDoor2], spawnPoint: new THREE.Vector3(-5, 3, 0), activated: false });

            // NEW: Thematic hazards
            const hazardRedMat = new THREE.MeshStandardMaterial({ color: 0xe53e3e });
            const hazardBlueMat = new THREE.MeshStandardMaterial({ color: 0x3182ce });
            
            const firePit = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), hazardRedMat);
            firePit.position.set(0, 4.6, -6);
            scene.add(firePit);
            hazards.push({ object: firePit, harmfulTo: 1 }); // Harmful to Watergirl (player 1)

            const waterPuddle = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 2), hazardBlueMat);
            waterPuddle.position.set(5, 6.6, 1);
            scene.add(waterPuddle);
            hazards.push({ object: waterPuddle, harmfulTo: 0 }); // Harmful to Fireboy (player 0)

            // NEW: Final platform and player-specific goal doors
            const finalPlatform = new THREE.Mesh(new THREE.BoxGeometry(6, 0.5, 6), platMat);
            finalPlatform.position.set(0, 8, -15);
            scene.add(finalPlatform);
            platforms.push(finalPlatform);

            const fireDoorMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const waterDoorMat = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });

            const fireDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), fireDoorMat);
            fireDoor.position.set(-1.5, 9.75, -15); // On top of the final platform
            scene.add(fireDoor);
            goals.push({ object: fireDoor, player: 0 }); // Goal for Fireboy

            const waterDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 1.5), waterDoorMat);
            waterDoor.position.set(1.5, 9.75, -15); // On top of the final platform
            scene.add(waterDoor);
            goals.push({ object: waterDoor, player: 1 }); // Goal for Watergirl

            // NEW: Add collectibles
            const redGemMat = new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0xff5555, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const blueGemMat = new THREE.MeshStandardMaterial({ color: 0x5599ff, emissive: 0x5599ff, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const gemGeo = new THREE.OctahedronGeometry(0.3, 0);
            const gemData = [
                { pos: new THREE.Vector3(-5, 3.5, 0), type: 'fire' },
                { pos: new THREE.Vector3(0, 5.5, -5), type: 'water' },
                { pos: new THREE.Vector3(5, 7.5, 0), type: 'fire' },
                { pos: new THREE.Vector3(5, 6.5, -10), type: 'water' },
                { pos: new THREE.Vector3(0, 9, -12), type: 'fire' }
            ];
            gemData.forEach(data => {
                const mat = data.type === 'fire' ? redGemMat : blueGemMat;
                const gem = new THREE.Mesh(gemGeo, mat);
                gem.position.copy(data.pos);
                scene.add(gem);
                collectibles.push({ mesh: gem, type: data.type });
                if (data.type === 'fire') {
                    totalRedCollectibles++;
                } else {
                    totalBlueCollectibles++;
                }
            });
        }
    
        function buildCompetitionLevel() {
            clearLevel();
            const platMat = new THREE.MeshStandardMaterial({ color: 0x68d391 });
            const hazardBlueMat = new THREE.MeshStandardMaterial({ color: 0x3182ce });
            const hazardRedMat = new THREE.MeshStandardMaterial({ color: 0xe53e3e });
            const fireDoorMat = new THREE.MeshStandardMaterial({ color: 0xff3300, emissive: 0xff3300, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const waterDoorMat = new THREE.MeshStandardMaterial({ color: 0x3366ff, emissive: 0x3366ff, emissiveIntensity: 0.6, transparent: true, opacity: 0.6 });
            const levelData = [
                { type: 'plat', size: [3, 1, 3], pos: [-6, 1, 0] }, { type: 'plat', size: [3, 1, 3], pos: [6, 1, 0] },
                { type: 'plat', size: [2, 1, 6], pos: [-6, 3, -8] }, { type: 'plat', size: [2, 1, 6], pos: [6, 3, -8] },
                { type: 'plat', size: [2, 1, 2], pos: [-3, 5, -15] }, { type: 'plat', size: [2, 1, 2], pos: [3, 5, -15] },
                { type: 'plat', size: [8, 1, 3], pos: [0, 7, -20] },
                { type: 'hazard', mat: hazardRedMat, size: [2, 0.5, 2], pos: [-6, 3.75, -6], player: 1 }, // Harmful to Watergirl
                { type: 'hazard', mat: hazardBlueMat, size: [2, 0.5, 2], pos: [6, 3.75, -6], player: 0 }, // Harmful to Fireboy
                { type: 'goal', mat: fireDoorMat, size: [1.5, 3, 1.5], pos: [-1.5, 8.5, -20], player: 0 }, // Fireboy's goal
                { type: 'goal', mat: waterDoorMat, size: [1.5, 3, 1.5], pos: [1.5, 8.5, -20], player: 1 }  // Watergirl's goal
            ];
            levelData.forEach(data => {
                const mat = data.mat || platMat;
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(...data.size), mat);
                mesh.position.set(...data.pos);
                scene.add(mesh);
                if (data.type === 'plat') platforms.push(mesh);
                else if (data.type === 'hazard') hazards.push({ object: mesh, harmfulTo: data.player });
                else if (data.type === 'goal') goals.push({ object: mesh, player: data.player });
            });

            // NEW: Add collectibles for competition
            const redGemMat = new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0xff5555, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const blueGemMat = new THREE.MeshStandardMaterial({ color: 0x5599ff, emissive: 0x5599ff, emissiveIntensity: 0.6, metalness: 0.6, roughness: 0.3 });
            const gemGeo = new THREE.OctahedronGeometry(0.3, 0);
            const gemData = [
                { pos: [-6, 2, -4], type: 'fire' }, { pos: [6, 2, -4], type: 'water' },
                { pos: [-6, 4, -12], type: 'fire' }, { pos: [6, 4, -12], type: 'water' },
                { pos: [0, 6, -15], type: 'fire' },
                { pos: [0, 8, -18], type: 'water' }
            ];
            gemData.forEach(data => {
                const mat = data.type === 'fire' ? redGemMat : blueGemMat;
                const gem = new THREE.Mesh(gemGeo, mat);
                gem.position.set(...data.pos);
                scene.add(gem);
                collectibles.push({ mesh: gem, type: data.type });
                if (data.type === 'fire') {
                    totalRedCollectibles++;
                } else {
                    totalBlueCollectibles++;
                }
            });
        }
    
        function getPlayerBounds(player) {
            return {
                minX: player.position.x - 0.5, maxX: player.position.x + 0.5,
                minY: player.position.y - 0.5, maxY: player.position.y + 1.3,
                minZ: player.position.z - 0.5, maxZ: player.position.z + 0.5
            };
        }
    
        function getObjectBounds(object) {
            if (object === floor) return { minX: -40, maxX: 40, minY: -0.1, maxY: 0.1, minZ: -40, maxZ: 40 };
            const box = new THREE.Box3().setFromObject(object);
            return {
                minX: box.min.x, maxX: box.max.x,
                minY: box.min.y, maxY: box.max.y,
                minZ: box.min.z, maxZ: box.max.z
            };
        }

        function checkCollision(bounds1, bounds2) {
            return bounds1.minX < bounds2.maxX && bounds1.maxX > bounds2.minX &&
                   bounds1.minY < bounds2.maxY && bounds1.maxY > bounds2.minY &&
                   bounds1.minZ < bounds2.maxZ && bounds1.maxZ > bounds2.minZ;
        }

        function updatePlayer(playerData, playerIndex) {
            const player = playerData.object;
            const controls = playerData.controls;
            if (keys[controls.left]) player.rotation.y += playerRotationSpeed;
            if (keys[controls.right]) player.rotation.y -= playerRotationSpeed;
            const moveDirection = new THREE.Vector3();
            if (keys[controls.forward]) moveDirection.z = -1;
            if (keys[controls.back]) moveDirection.z = 1;
            moveDirection.applyQuaternion(player.quaternion).multiplyScalar(playerSpeed);
            const originalX = player.position.x;
            const originalZ = player.position.z;
            player.position.x += moveDirection.x;
            player.position.z += moveDirection.z;
            let playerBounds = getPlayerBounds(player);
            for (const platform of platforms) {
                if (platform === floor) continue;
                const platformBounds = getObjectBounds(platform);
                if (checkCollision(playerBounds, platformBounds) && playerBounds.minY < platformBounds.maxY + 0.1) {
                    player.position.x = originalX;
                    player.position.z = originalZ;
                    break;
                }
            }
            if (keys[controls.jump] && playerIndex === 0 && playerData.isGrounded) {
                playerData.isGrounded = false;
                playerData.velocityY = jumpHeight;
                jumpFbSound.play();
            }
            if (keys[controls.jump] && playerIndex === 1 && playerData.isGrounded) {
                playerData.isGrounded = false;
                playerData.velocityY = jumpHeight;
                jumpWgSound.play();
            }
            playerData.velocityY += gravity;
            player.position.y += playerData.velocityY;
            playerData.isGrounded = false;
            let newPlayerBounds = getPlayerBounds(player);
            for (const platform of platforms) {
                const platformBounds = getObjectBounds(platform);
                if (checkCollision(newPlayerBounds, platformBounds)) {
                    if (playerData.velocityY <= 0) {
                        player.position.y = platformBounds.maxY + 0.5;
                        playerData.velocityY = 0;
                        playerData.isGrounded = true;
                    } else {
                        player.position.y = platformBounds.minY - 1.3;
                        playerData.velocityY = 0;
                    }
                    break;
                }
            }
            if (player.position.y < -20) {
                player.position.copy(playerData.spawnPoint);
                playerData.velocityY = 0;
                playerData.isGrounded = true;
            }
            // MODIFIED: Hazard check now runs for both modes
            for (const hazard of hazards) {
                if (hazard.harmfulTo === playerIndex && checkCollision(getPlayerBounds(player), getObjectBounds(hazard.object))) {
                    player.position.copy(playerData.spawnPoint);
                    playerData.velocityY = 0;
                    playerData.isGrounded = true;
                }
            }

            // NEW: Collectible collision check
            const playerBoundsForCollect = getPlayerBounds(player);
            for (let i = collectibles.length - 1; i >= 0; i--) {
                const gemData = collectibles[i];
                const gem = gemData.mesh;
                // Check if the player type matches the gem type
                if (playerData.type === gemData.type && checkCollision(playerBoundsForCollect, getObjectBounds(gem))) {
                    scene.remove(gem);
                    collectibles.splice(i, 1);
                    if (gemData.type === 'fire') {
                        redCollectedCount++;
                    } else {
                        blueCollectedCount++;
                    }
                    updateGemUI();
                    if (collectSound.isPlaying) collectSound.stop();
                    collectSound.play();
                }
            }
            // Competition-specific goal check
            if (gameMode === 'competition') {
                for (const goal of goals) {
                    if (goal.player === playerIndex && !raceFinished) {
                        const allOwnGemsCollected = (playerData.type === 'fire' && redCollectedCount >= totalRedCollectibles) ||
                                                    (playerData.type === 'water' && blueCollectedCount >= totalBlueCollectibles);

                        if (allOwnGemsCollected && checkCollision(getPlayerBounds(player), getObjectBounds(goal.object))) {
                            raceFinished = true;
                            endGame(playerIndex);
                        }
                    }
                }
            }
        }
    
        function updateCheckpoints() {
            if (gameMode !== 'teamwork') return;
            const player1Bounds = getPlayerBounds(players[0].object);
            const player2Bounds = getPlayerBounds(players[1].object);
            for (const checkpoint of checkpoints) {
                if (checkpoint.activated) continue;
                const door1Bounds = getObjectBounds(checkpoint.pair[0]);
                const door2Bounds = getObjectBounds(checkpoint.pair[1]);
                // For teamwork checkpoints, player 1 (Fireboy) must be on the red door, player 2 (Watergirl) on the blue
                if (checkCollision(player1Bounds, door1Bounds) && checkCollision(player2Bounds, door2Bounds)) {
                    checkpoint.activated = true;
                    const spawnPoint = checkpoint.spawnPoint;
                    players[0].spawnPoint.copy(spawnPoint);
                    players[1].spawnPoint.copy(spawnPoint);
                    highestLevelUnlocked = Math.max(highestLevelUnlocked, 1);
                    checkpoint.pair[0].material.color.set(0x68d391);
                    checkpoint.pair[1].material.color.set(0x68d391);
                    saveProgress();
                }
            }
        }
        
        // NEW: Function to check for the teamwork win condition
        function checkTeamworkWin() {
            const allGemsCollected = redCollectedCount >= totalRedCollectibles && blueCollectedCount >= totalBlueCollectibles;
            if (gameMode !== 'teamwork' || raceFinished || goals.length < 2 || !allGemsCollected) return;

            const fireboyGoal = goals.find(g => g.player === 0)?.object;
            const watergirlGoal = goals.find(g => g.player === 1)?.object;

            if (!fireboyGoal || !watergirlGoal) return;

            const player1Bounds = getPlayerBounds(players[0].object);
            const player2Bounds = getPlayerBounds(players[1].object);

            const fireboyAtGoal = checkCollision(player1Bounds, getObjectBounds(fireboyGoal));
            const watergirlAtGoal = checkCollision(player2Bounds, getObjectBounds(watergirlGoal));

            if (fireboyAtGoal && watergirlAtGoal) {
                raceFinished = true;
                // Make doors solid green to show completion
                fireboyGoal.material.color.set(0x28a745);
                fireboyGoal.material.emissive.set(0x28a745);
                watergirlGoal.material.color.set(0x28a745);
                watergirlGoal.material.emissive.set(0x28a745);
                endGame(); // No specific winner in teamwork
            }
        }

        function updateGemUI() {
            if (!player1GemUI || !player2GemUI) return;

            // Fireboy's UI (Player 1) - always shows red gem progress
            player1GemUI.innerHTML = `Gems: <span style="color: #ff5555;">${redCollectedCount} / ${totalRedCollectibles}</span>`;
            
            // Watergirl's UI (Player 2) - always shows blue gem progress
            player2GemUI.innerHTML = `Gems: <span style="color: #5599ff;">${blueCollectedCount} / ${totalBlueCollectibles}</span>`;
        }

        function endGame(winnerIndex) {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            if (SurvivalMusic.isPlaying) {
                SurvivalMusic.stop();
            }
            if (CompetitionMusic.isPlaying) {
                CompetitionMusic.stop();
            }
            gameState = 'winner';
            
            if (gameMode === 'competition') {
                winnerText.textContent = `${players[winnerIndex].name} Wins!`;
                winnerSubtext.textContent = `First to the finish line!`;
                raceAgainButton.textContent = "Race Again";
            } else {
                winnerText.textContent = `Level Complete!`;
                winnerSubtext.textContent = `You reached the goal together!`;
                raceAgainButton.textContent = "Play Again"; // Or "Next Level" in the future
            }
            showScreen('winner-screen');
        }
    
        function startCountdown() {
            let count = 3;
            countdown.textContent = count;
            countdown.classList.remove('hidden');
            const interval = setInterval(() => {
                count--;
                countdown.textContent = count > 0 ? count : 'GO!';
                if (count <= -1) {
                    clearInterval(interval);
                    countdown.classList.add('hidden');
                    gameState = 'playing';
                    animate();
                }
            }, 1000);
        }
    
        const cameraOffset = new THREE.Vector3(0, 5, 8);
        const smoothness = 0.05;
        function updateCamera(camera, player) {
            // 1. Calculate the ideal camera position as before
            const idealOffset = cameraOffset.clone().applyQuaternion(player.quaternion);
            let targetPosition = player.position.clone().add(idealOffset);

            // 2. Check for collisions between the player and the camera
            const playerHead = player.position.clone().add(new THREE.Vector3(0, 1, 0)); // Raycast from near player's head
            const direction = targetPosition.clone().sub(playerHead).normalize();
            const distance = playerHead.distanceTo(targetPosition);
            const raycaster = new THREE.Raycaster(playerHead, direction, 0, distance);

            const intersects = raycaster.intersectObjects(platforms, false); // Don't check children

            if (intersects.length > 0) {
                // If the ray hits a platform, move the camera to the intersection point
                // instead of its ideal position behind the wall.
                targetPosition = intersects[0].point.clone().sub(direction.multiplyScalar(0.5)); // Pull back slightly from the wall
            }

            // 3. Smoothly move and look at the player as before
            camera.position.lerp(targetPosition, smoothness);
            const lookAtTarget = player.position.clone();
            lookAtTarget.y += 0.5;
            camera.lookAt(lookAtTarget);
        }

        function animate() {
            if (gameState !== 'playing' && gameState !== 'paused') return;
            animationFrameId = requestAnimationFrame(animate);
    
            if (gameState === 'playing') {
                // NEW: Animate collectibles
                collectibles.forEach(gemData => {
                    gemData.mesh.rotation.y += 0.02;
                });
                players.forEach((player, index) => updatePlayer(player, index));
                updateCheckpoints();
                checkTeamworkWin(); // NEW
            }
    
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            renderer.setScissorTest(true);
            renderer.setScissor(0, 0, screenWidth / 2, screenHeight);
            renderer.setViewport(0, 0, screenWidth / 2, screenHeight);
            updateCamera(camera1, players[0].object);
            renderer.render(scene, camera1);
            renderer.setScissor(screenWidth / 2, 0, screenWidth / 2, screenHeight);
            renderer.setViewport(screenWidth / 2, 0, screenWidth / 2, screenHeight);
            updateCamera(camera2, players[1].object);
            renderer.render(scene, camera2);
            renderer.setScissorTest(false);
        }
    
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera1.aspect = (width / 2) / height;
            camera1.updateProjectionMatrix();
            camera2.aspect = (width / 2) / height;
            camera2.updateProjectionMatrix();
        });
    
        function showScreen(screenId) {
            mainMenu.classList.add('hidden');
            submenu.classList.add('hidden');
            gameContainer.classList.add('hidden');
            confirmationDialog.classList.add('hidden');
            winnerScreen.classList.add('hidden');
            document.getElementById(screenId)?.classList.remove('hidden');
        }
    
        function resetLevelState(isNewGame) {
            raceFinished = false;
            const defaultSpawn1 = new THREE.Vector3(-2, 0.5, 0);
            const defaultSpawn2 = new THREE.Vector3(2, 0.5, 0);
            redCollectedCount = 0;
            blueCollectedCount = 0;
    
            if (gameMode === 'competition') {
                players[0].spawnPoint.set(-6, 1.5, 2);
                players[1].spawnPoint.set(6, 1.5, 2);
            } else { // Teamwork
                let p1Spawn = isNewGame || !savedSpawnPoint ? defaultSpawn1 : new THREE.Vector3().copy(savedSpawnPoint);
                let p2Spawn = isNewGame || !savedSpawnPoint ? defaultSpawn2 : new THREE.Vector3().copy(savedSpawnPoint);
                players[0].spawnPoint.copy(p1Spawn);
                players[1].spawnPoint.copy(p2Spawn);
            }

            players.forEach(p => {
                p.object.position.copy(p.spawnPoint);
                p.velocityY = 0;
                p.isGrounded = true;
            });
        }
    
        function updateSubmenuButtons() {
            if (hasSavedProgress) {
                resumeGameButton.classList.remove('hidden');
                newGameButton.classList.remove('hidden');
                startGameButton.classList.add('hidden');
            } else {
                resumeGameButton.classList.add('hidden');
                newGameButton.classList.add('hidden');
                startGameButton.classList.remove('hidden');
            }
        }
    
        function startGame(mode, isResume = false) {
            // Resume audio context on user interaction - this is crucial for browsers
            if (listener1.context.state === 'suspended') {
                listener1.context.resume();
            }

            gameMode = mode;
            if (mode === 'teamwork') {
                if (CompetitionMusic.isPlaying) CompetitionMusic.stop();
                buildTeamworkLevel();
                if (!SurvivalMusic.isPlaying) {
                    SurvivalMusic.play();
                    SurvivalMusic.setLoop(true);
                }
            } else if (mode === 'competition') {
                if (SurvivalMusic.isPlaying) SurvivalMusic.stop();
                buildCompetitionLevel();
                if (!CompetitionMusic.isPlaying) {
                    CompetitionMusic.play();
                    CompetitionMusic.setLoop(true);
                }
            }
    
            resetLevelState(!isResume);
            updateGemUI();
            showScreen('game-container');
    
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
    
            if (mode === 'competition') {
                gameState = 'countdown';
                startCountdown();
            } else {
                gameState = 'playing';
                animate();
            }
        }
    
        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                pauseMenu.classList.remove('hidden');
                if (gameMode === 'teamwork' && SurvivalMusic.isPlaying) {
                    SurvivalMusic.pause();
                }
                if (gameMode === 'competition' && CompetitionMusic.isPlaying) {
                    CompetitionMusic.pause();
                }
            } else if (gameState === 'paused') {
                gameState = 'playing';
                pauseMenu.classList.add('hidden');
                if (gameMode === 'teamwork') {
                    SurvivalMusic.play();
                }
                if (gameMode === 'competition') {
                    CompetitionMusic.play();
                }
            }
        }
    
        function returnToMenu() {
            if (gameMode === 'teamwork') {
                saveProgress();
            }
            if (SurvivalMusic.isPlaying) {
                SurvivalMusic.stop();
            }
            if (CompetitionMusic.isPlaying) {
                CompetitionMusic.stop();
            }
            pauseMenu.classList.add('hidden');
            showScreen('main-menu');
            gameState = 'menu';
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }
    
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'p' && (gameState === 'playing' || gameState === 'paused')) {
                togglePause();
            }
        });
    
        // --- EVENT LISTENERS ---
        resumeButton.addEventListener('click', togglePause);
        restartCheckpointButton.addEventListener('click', () => {
            players.forEach(p => p.object.position.copy(p.spawnPoint));
            if(gameState === 'paused') togglePause();
        });
        returnToMenuButton.addEventListener('click', returnToMenu);
        teamworkButton.addEventListener('click', () => {
            gameMode = 'teamwork';
            loadProgress();
            updateSubmenuButtons();
            showScreen('submenu');
        });
        competitionButton.addEventListener('click', () => startGame('competition', false));
        backToMainButton.addEventListener('click', () => showScreen('main-menu'));
        resumeGameButton.addEventListener('click', () => startGame('teamwork', true));
        startGameButton.addEventListener('click', () => startGame('teamwork', false));
        newGameButton.addEventListener('click', () => showScreen('confirmation-dialog'));
        confirmYesButton.addEventListener('click', () => {
            localStorage.removeItem('3dup-up_progress');
            localStorage.removeItem('3dup-up_spawnPoint');
            hasSavedProgress = false;
            savedSpawnPoint = null;
            startGame('teamwork', false);
        });
        confirmNoButton.addEventListener('click', () => showScreen('submenu'));
        raceAgainButton.addEventListener('click', () => {
            if (gameMode === 'competition') {
                startGame('competition', false);
            } else {
                startGame('teamwork', false);
            }
        });
        backToMenuButton.addEventListener('click', () => {
            showScreen('main-menu');
            gameState = 'menu';
        });
    
        // Initialize on load
        loadProgress();
    </script>
</body>
</html>